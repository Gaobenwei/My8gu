# 5.21
&emsp;&emsp;远程下载文件时，大文件没问题 提示下载中 下载完成提示，小文件反而失败 没有提示下载完成
# 7.7督学
## IOCP
### I/O 完成端口
&emsp;&emsp;I/O 完成端口提供了一个高效的线程模型，用于处理多处理器系统上的多个异步 I/O 请求。 当**进程创建 I/O 完成端口**时，系统会**为线程创建关联的队列对象**，该对象的唯一目的是为这些请求提供服务。 与在收到 I/O 请求时创建线程相比，处理多个并发异步 I/O 请求的进程可以***通过将 I/O 完成端口与预分配的线程池结合***使用来更快、更高效地执行此操作。
&emsp;&emsp;***I/O 完成端口与创建它的进程相关联，并且不能在进程之间共享。 但是，同一进程中的线程之间可共享单个句柄。***
#### I/O 完成端口的工作原理
&emsp;&emsp;CreateIoCompletionPort 函数创建 I/O 完成端口，并将一个或多个文件句柄与该端口相关联。 当其中一个文件句柄上的异步 I/O 操作完成时，I/O 完成数据包将排入先进先出 (FIFO) 相关 I/O 完成端口的顺序。
&emsp;&emsp;当文件句柄与完成端口关联时，传入的状态块不会更新，直到从完成端口中删除数据包。线程 (main线程创建的线程或main线程本身) **使用 GetQueuedCompletionStatus 函数等待完成数据包排队到 I/O 完成端口**，而不是直接等待异步 I/O 完成。 这意味着，当完成数据包发布到线程时，系统会释放与该端口关联的最后 (最近的) 线程，并向其传递最早的 I/O 完成的完成信息。
&emsp;&emsp;尽管任意数量的线程都可以为指定的 I/O 完成端口调用 GetQueuedCompletionStatus ，但当指定线程首次调用 GetQueuedCompletionStatus 时，它会与指定的 I/O 完成端口相关联，直到发生以下三种情况之一：线程退出、指定不同的 I/O 完成端口或关闭 I/O 完成端口。 **换句话说，单个线程最多可以与一个 I/O 完成端口相关联。**
&emsp;&emsp;当一个完成包排队到一个I/O完成端口时，系统首先检查有多少与该端口相关的线程正在运行。如果运行的线程数少于并发值，则允许一个等待线程(最近的一个)处理完成包。当一个正在运行的线程完成它的处理时，它通常会再次调用GetQueuedCompletionStatus，此时它要么返回下一个完成包，要么等待队列为空。
&emsp;&emsp;线程可以使用 PostQueuedCompletionStatus 函数将完成数据包放置在 I/O 完成端口的队列中。 这样，除了从 I/O 系统接收 I/O 完成数据包外，完成端口还可用于从进程的其他线程接收通信。 PostQueuedCompletionStatus 函数允许应用程序将自己的特殊用途完成数据包排队到 I/O 完成端口，而无需启动异步 I/O 操作。 例如，这对于通知工作线程外部事件很有用。
&emsp;&emsp;I/O 完成端口句柄以及与该特定 I/O 完成端口关联的每个文件句柄称为 对 I/O 完成端口的引用。 当不再引用 I/O 完成端口时，将释放该端口。 因此，必须正确关闭所有这些句柄才能释放 I/O 完成端口及其关联的系统资源。 满足这些条件后，应用程序应通过调用 CloseHandle 函数关闭 I/O 完成端口句柄。
### 相关函数
```c++
HANDLE CreateIoCompletionPort(
  [in]           HANDLE    FileHandle,
  [in, optional] HANDLE    ExistingCompletionPort,
  [in]           ULONG_PTR CompletionKey, //传递已完成IO相关信息，单文件句柄，包含指定文件每次IO完成包数据信息。
  [in]           DWORD     NumberOfConcurrentThreads  //此值限制与完成端口关联的可运行线程数。
);
```
&emsp;&emsp;对于参数3 ULONG_PTR CompletionKey，不了解。
&emsp;&emsp;可以指示 I/O 系统将 I/O 完成通知数据包发送到 I/O 完成端口，数据包将在这些端口上排队。 CreateIoCompletionPort 函数提供此功能。
可以在三种不同的模式下使用 CreateIoCompletionPort：
&ensp;1    仅创建 I/O 完成端口，而不将其与文件句柄相关联。
&ensp;2    将现有 I/O 完成端口与文件句柄相关联。
&ensp;3    在单个调用中执行创建和关联。
&emsp;&emsp;如果 GetQueuedCompletionStatus 函数成功，它将从完成端口取消对成功 I/O 操作的完成数据包的排队，并将信息存储在以下参数指向的变量中： lpNumberOfBytes、 lpCompletionKey 和 lpOverlapped。
&emsp;&emsp;当队列中有完成数据包等待，但由于端口已达到其并发限制，无法满足任何等待时，会出现最有效的方案。 考虑在 GetQueuedCompletionStatus 函数调用中等待一个和多个线程的并发值会发生什么情况。 在这种情况下，如果队列始终等待完成数据包，当正在运行的线程调用 GetQueuedCompletionStatus 时，它不会阻止执行，因为如前所述，线程队列是 LIFO。 相反，此线程将立即选取下一个排队的完成数据包。 不会发生线程上下文切换，因为正在运行的线程不断拾取完成数据包，而其他线程无法运行。

>使用IOCP的基本步骤很简单：
1：创建IOCP对象，由它负责管理多个Socket和I/O请求。CreateIoCompletionPort需要将IOCP对象和IOCP句柄绑定。
2：创建一个工作线程池，以便Socket发送I/O请求给IOCP对象后，由这些工作线程进行I/O操作。注意，创建这些线程的时候，将这些线程绑定到IOCP上。
3：创建一个监听的socket。
4：轮询，当接收到了新的连接后，将socket和完成端口进行关联并且投递给IOCP一个I/O请求。注意：将Socket和IOCP进行关联的函数和创建IOCP的函数一样，都是CreateIoCompletionPort，不过注意传参必然是不同的。
5：因为是异步的，我们可以去做其他，等待IOCP将I/O操作完成会回馈我们一个消息，我们再进行处理。
其中需要知道的是：I/O请求被放在一个I/O请求队列里面，对，是队列，LIFO机制。当一个设备处理完I/O请求后，将会将这个完成后的I/O请求丢回IOCP的I/O完成队列。
我们应用程序则需要在GetQueuedCompletionStatus去询问IOCP，该I/O请求是否完成。
其中有一些特殊的事情要说明一下，我们有时有需要人工的去投递一些I/O请求，则需要使用PostQueuedCompletionStatus函数向IOCP投递一个I/O请求到它的请求队列中。

>注意：这个参数比较特殊。任何从OVERLAPPED 继承的
类型，或者第一个属性为OVERLAPPED 的类型，都可
以通过CONTAINING_RECORD来获取原始类型的地
址。具体可见[文档109页描述](E:/project/cpp_study/qin/%E6%98%93%E6%92%ADwindows/%E6%98%93%E6%92%AD%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8.pdf)
## Accept、AcceptEX
&emsp;&emsp;accept是阻塞的；在一个端口监听，必须启动一个专用线程调用accept。acceptEx是异步的，可以同时对很多端口监听（监听端口的数量没有上限的限制）。采用迂回的方式，使用accept监听，一个线程最多监听64个端口。这一点可能不是AcceptEx最大优点，毕竟同时对多个端口监听的情况非常少见。
&emsp;&emsp;AcceptEx可以返回更多的数据。
&emsp;&emsp;AcceptEx是先准备套接字（socket）后接收。为了应对突发的连接高峰，可以多次投放AcceptEx。accept是事后建立SOCKET，就是tcp三次握手完成后，accept调用才返回，再生成socket。生成套接字是相对比较耗时的操作，accept的方式无法及时处理突发连接。对于AcceptEx的处理方式为建议做如下处理：一个线程负责创建socket，一个线程负责处理AcceptEx返回。
```c++
//acceptex示例说明
class IocpAcceptEx
{
public:
    IocpAcceptEx();
    ~IocpAcceptEx();
    //设置回调接口。当accept成功，调用回调接口。
    void SetCallback(IAcceptCallback* callback);
    // 增加监听端口
    void AddListenPort(UINT16 port);
    //启动服务
    BOOL Start();
    void Stop();
}
#define POST_ACCEPT 1
//使用IocpAcceptEx类，必须实现该接口。接收客户端的连接
class IAcceptCallback
{
public:
    virtual void OnAcceptClient(SOCKET hSocketClient, UINT16 nListenPort) = 0;
};    
//AcceptEx不但需要与监听端口绑定，还需要与完成端口绑定。
//（1）所以程序的第一步是创建完成端口：
m_hIocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 0);
if (m_hIocp == NULL)
     return FALSE;
    
//（2）监听端口的创建与绑定
SOCKET serversocket=WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
if(serversocket==INVALID_SOCKET) return false;
/*绑定*/
SOCKADDR_IN addr;
memset(&addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_addr.s_addr =  INADDR_ANY ;
addr.sin_port = htons(port);
if (bind(serverSocket, (sockaddr *)&addr, sizeof(addr)) != 0)
{
    closesocket(serverSocket);
    serverSocket = INVALID_SOCKET;
    return false;
}
//启动监听
if (listen(serverSocket, SOMAXCONN) != 0)
{
    closesocket(serverSocket);
    serverSocket = INVALID_SOCKET;
    return false;
}
//监听端口与完成端口绑定
if(CreateIoCompletionPort((HANDLE)serverSocket,m_hIocp,(ULONG_PTR)this,0)==NULL)
{
    closesocket(serverSocket);
    serverSocket = INVALID_SOCKET;
    return false;
}

// （3）投递AcceptEx
struct AcceptOverlapped
{
    OVERLAPPED     overlap;
    INT32 opType;
    SOCKET serverSocket;
    SOCKET clientSocket;
    char lpOutputBuf[128];
    DWORD dwBytes;
};

int IocpAcceptEx::NewAccept(SOCKET serverSocket)
{
    //创建socket
    SOCKET _socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); 
    AcceptOverlapped *ov = new AcceptOverlapped();
    ZeroMemory(ov,sizeof(AcceptOverlapped));
    ov->opType = POST_ACCEPT;
    ov->clientSocket = _socket;
    ov->serverSocket = serverSocket;
    //存放网络地址的长度
    int addrLen = sizeof(sockaddr_in) + 16;
    
    int bRetval=AcceptEx(serverSocket, _socket, ov->lpOutputBuf,0,addrLen, addrLen,&ov->dwBytes, (LPOVERLAPPED)ov);
    if (bRetVal == FALSE)
    {
        int error = WSAGetLastError();
        if (error != WSA_IO_PENDING)
        {
            closesocket(_socket);
            return 0;
        }
    }
    return 1;
}
```
&emsp;&emsp;AcceptEx是非阻塞操作，调用会立即返回。当有客户端连接时，怎么得到通知。答案是通过完成端口返回。注意有一个步骤：监听端口与完成端口绑定，就是serverSocket与m_hIocp绑定，所以当有客户端连接serverSocket时，m_hIocp会得到通知。需要生成线程，等待完成端口的通知。
```cpp
// （4）通过完成端口，获取通知
DWORD dwBytesTransferred;
ULONG_PTR    Key;
BOOL rc;
int error;

AcceptOverlapped *lpPerIOData = NULL;
while (m_bServerStart)
{
    error = NO_ERROR;
    rc = GetQueuedCompletionStatus(
        m_hIocp,
        &dwBytesTransferred,
        &Key,
        (LPOVERLAPPED *)&lpPerIOData,
        INFINITE);

    if (rc == FALSE)
    {
        error = 0;
        if (lpPerIOData == NULL)
        {
            DWORD lastError = GetLastError();
            if (lastError == WAIT_TIMEOUT)
            {
                continue;
            }
            else
            {
                assert(false);
                return lastError;
            }
        }
    }
    if (lpPerIOData != NULL)
    {
        switch (lpPerIOData->opType)
        {
        case POST_ACCEPT:
        {
            OnIocpAccept(lpPerIOData, dwBytesTransferred, error);
        }
        break;
        }
    }
    else 
    {    }
}
return 0;
```
### 结合线程池很好
```cpp
DWORD WINAPI IocpAcceptEx::AcceptExThreadPool(PVOID pContext)
{
    ThreadPoolParam *param = (ThreadPoolParam*)pContext;
    param->pIocpAcceptEx->NewAccept(param->ServeSocket);
    delete param;
    return 0;
}

int IocpAcceptEx::OnIocpAccept(AcceptOverlapped *acceptData, int transLen, int error)
{
    m_IAcceptCallback->OnAcceptClient(acceptData->clientSocket, acceptData->serverSocket);

    //当一个AcceptEx返回，需要投递一个新的AcceptEx。 
    //使用线程池好像有点小题大做。前文已说过，套接字的创建相对是比较耗时的操作。
    //如果不在线程池投递AcceptEx，AcceptEx的优点就被抹杀了。
    ThreadPoolParam *param = new ThreadPoolParam();
    param->pIocpAcceptEx = this;
    param->ServeSocket = acceptData->serverSocket;
    QueueUserWorkItem(AcceptExThreadPool, this, 0);

    delete acceptData;
    return 0;
}
```
## Create线程的数量
真正并发同时执行最大线程数，一般推介是CPU核心数*2.
## 内存对齐
1、    分配内存的顺序是按照声明的顺序，依次安排内存。
2、    每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。
3、    最后整个结构体的大小必须是里面变量类型最大值的整数倍。
添加了#pragma pack(n)后规则就变成了下面这样： 
1、    偏移量要是n和当前变量大小中较小值的整数倍
2、    整体大小要是n和最大变量大小中较小值的整数倍
3、    n值必须为1,2,4,8…，为其他值时就按照默认的分配规则
## 监视画面设计
&emsp;&emsp;基本原理就是将对方屏幕显示做成图片，然后回传到监控机器，只要回传的速度够快，我们就能观察到对方屏幕的活动。
&emsp;&emsp;但是考虑到屏幕上一个点是四个字节（RGBA），一般1920×1080的分辨率会有至少829440个字节的图片需求。我们会在截屏之后，将其压缩为png格式的图片，来缩小需要的内存空间。不用jpg，是因为png能在相同的清晰度情况下，有更小的体积。
### 推流 音视频编码(未完成)
## 线程池
&emsp;&emsp;1 首先要先封装线程类。线程的创建、销毁、设置、启动、停止和主线程函数都要设置好接口。
&emsp;&emsp;2 然后设计线程池类。需要设计好接口：初始化、大小调整、添加任务、关闭、获取尺寸、启动等。线程池有一个任务列表属性，一个事件属性和一个互斥锁。外部投递进来的任务先是加入任务列表属性。然后设置事件属性。每个子线程都会等待事件。一旦事件被设置，则获取到该事件的线程就会通过互斥锁来同步任务列表，取其中一个任务出来开始执行。
&emsp;&emsp;3 设计任务类。任务类需要有一个任务函数接口。这个接口线程类会自动调用。此外需要封装一些做参数用的属性。一般任务类是基类，用户可以依据自己的需求去派生子类。子类重载任务函数即可，也可以自己追加一些属性，用于任务函数。
&emsp;&emsp;4 最后整合三个模块，一个最原始的线程池就完成了。

## select 缺点
基于 select 的 I/O 复用技术速度慢的原因
第 12 章实现了基于 select 的 I/O 复用技术服务端，其中有不合理的设计如下：
1. 调用 select 函数后常见的针对所有文件描述符的循环语句
2. 每次调用 select 函数时都需要向该函数传递监视对象信息

上述两点可以从 echo_selectserv.c 得到确认，调用 select 函数后，并不是把发生变化的文件描述符单独集中在一起，而是通过作为监视对象的 fd_set 变量的变化，找出发生变化的文件描述符（54,56行），因此无法避免针对所有监视对象的循环语句。而且，作为监视对象的 fd_set 会发生变化，所以调用 select 函数前应该复制并保存原有信息，并在每次调用 select 函数时传递新的监视对象信息。
select 性能上最大的弱点是：每次传递监视对象信息，准确的说，select 是监视套接字变化的函数。而套接字是操作系统管理的，所以 select 函数要借助操作系统才能完成功能。select 函数的这一缺点可以通过如下方式弥补：
仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项
这样就无需每次调用 select 函数时都想操作系统传递监视对象信息，但是前提操作系统支持这种处理方式。Linux 的支持方式是 epoll ，Windows 的支持方式是 IOCP。
## Iocp和epoll的区别
### 相同点：
&emsp;&emsp;都是用于高性能io的函数
&emsp;&emsp;都可以使用reactor模式来封装
&emsp;&emsp;都比select、poll模式性能更高
### 不同点：
&emsp;&emsp;IOCP往往配合重叠IO来实现
&emsp;&emsp;Epoll则是通过额外参数传递来实现

&emsp;&emsp;IOCP可以手动通过接口函数来触发事件
&emsp;&emsp;Epoll则无法做到，必须依赖绑定的io对象来触发事件

&emsp;&emsp;IOCP是Windows下使用
&emsp;&emsp;Epoll只能在Linux下使用
### 事件通知方式
第一个不同点是二者的事件通知方式，***主要体现在内核帮用户做了多少工作***。具体而言
1.    IOCP是IO操作完毕之后，通过Get(GetQueuedCompletionStatus)函数获得一个完成的事件通知。
Epoll是当你希望进行一个IO操作时，向Epoll查询是否可读或者可写，若处于可读或可写状态后，Epoll会通过epoll_wait进行通知。
2.    IOCP封装了异步的消息事件的通知机制，同时封装了部分IO操作。但Epoll仅仅封装了一个异步事件的通知机制，并不负责IO读写操作。Epoll保持了事件通知和IO操作间的独立性，更加简单灵活。
>基于上面的描述，我们可以知道Epoll不负责IO操作，所以它只告诉你当前可读可写了，并且将协议读写缓冲填充，由用户去读写控制，此时我们可以做出额 外的许多操作。IOCP则直接将IO通道里的读写操作都做完了才通知用户，当IO通道里发生了堵塞等状况我们是无法控制的。
## 进程、线程
&emsp;&emsp;1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序
&emsp;&emsp;2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位
&emsp;&emsp;每个进程的内存空间都由保存全局变量的「数据区」、向 malloc 等函数动态分配提供空间的堆（Heap）、函数运行时间使用的栈（Stack）构成。每个进程都有独立的这种空间，多个进程的内存结构如图所示：
![进程间独立的内存](image.png)
&emsp;&emsp;但如果以获得多个代码执行流为目的，则不应该像上图那样完全分离内存结构，而只需分离栈区域。通过这种方式可以获得如下优势：
&ensp;1    上下文切换时不需要切换数据区和堆
&ensp;2    可以利用数据区和堆交换数据
实际上这就是线程。线程为了保持多条代码执行流而隔开了栈区域，因此具有如下图所示的内存结构：
![线程内存结构](image-1.png)
&emsp;&emsp;如图所示，多个线程共享数据区和堆。为了保持这种结构，线程将在进程内创建并运行。也就是说，进程和线程可以定义为如下形式：
&ensp;进程：在操作系统构成单独执行流的单位
&ensp;线程：在进程构成单独执行流的单位
### linux中进程与线程
&emsp;&emsp;在Linux中，开启进程一般通过exec系列函数或者fork函数来完成。fork函数会对线程造成影响，所以我们一定要先定好进程结构，
然后再开启线程。
&emsp;&emsp;首先，由于线程无法被复制，所以在子进程中，一些线程会消失
（没有被复制过来）
&emsp;&emsp;其次，如果程序逻辑依赖多线程模式的时候，fork可能在子进程
中破坏掉这种模式，进而使得程序出现无法预料的问题。
&emsp;&emsp;所以一定要先准备好进程结构，再去使用线程！！！
## 进程的3个状态
&ensp;1    就绪状态（ready）：等待被调度
&ensp;2    运行状态（running）
&ensp;3    阻塞状态（waiting）：等待资源
应该注意以下内容：
&emsp;&emsp;只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU  时间片用完之后就会转为就绪状态，等待下一次调度。
&emsp;&emsp;阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。
## MVC
&emsp;&emsp;我在该项目中使用了 MVC 设计模式和 IOCP 模型。
&emsp;&emsp;MVC 设计模式是一种用于开发用户界面的模式，它将应用程序分为三个部分：模型、视图和控制器。其中，模型代表应用程序的数据和业务逻辑，视图是用户界面，控制器负责逻辑控制。MVC 设计模式有助于提高应用程序的可重用性和可维护性，对于远程桌面控制软件中的用户界面设计和业务逻辑实现非常适用。
IOCP 模型是一种基于事件驱动的异步 I/O 模型，它能够高效地处理大量连接和数据传输请求，提高系统的性能和稳定性。在远程桌面控制软件中，使用 IOCP 模型可以实现高效的网络通信，处理大量的连接和数据传输请求。
M表示model，即模型层
V表示view，即显示层、表示层、界面层
C表示controller，即控制层
界面层不关心具体逻辑，也不关心具体数据。如果界面层需要数据，则开放接口或者属性，让其他层来调用。注意，界面层需要处理用户的交互。将用户的行为反馈给控制层，但是如何处理要依据具体的情况来定。如果是界面层的处理，则自己完成；如果还涉及业务处理，则交由控制层来处理
模型层只关心数据模型，对于界面层如何展示、控制层如何使用，毫不关心。如果外部需要使用某些数据，或者进行某些数据处理，模型层会开放接口出来，供外部使用。
控制层是MVC的核心，这层的代码可复用性最差，一般都是和具体业务深度绑定的。控制层负责整个产品的逻辑和调度。从界面层来的用户请求，到模型层的数据摘选，以及业务进度的控制，都是在这一层完成的。

## pthread_join pthread_detach 引出的线程状态等
linux中pthread_detach()解析
&emsp;&emsp;使用pthread_create创建的线程有两种状态：joinable和unjoinable。默认是joinable 状态，可以通过这个api 来获取其状态
&emsp;&emsp;pthread_attr_getdetachstate另外可以通过如下代码来设置为状态joinable 还是 unjoinable
```cpp
pthread_attr_t attr;
pthread_attr_init(&attr);
pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
pthread_create(&thr, &attr, &thread_start, NULL);
```
&emsp;&emsp;还有一种方法是线程创建后在线程中调用 pthread_detach, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。
```cpp
void  ThreadFunc( void *ptr )
{       
    pthread_detach(pthread_self()); // 此时状态改为 unjoinable 
    pthread_exit(0) ;
}
pthread_t tid;
int status = pthread_create(&tid, NULL, ThreadFunc, NULL);
if(status != 0)
{
    perror("pthread_create error");
}
```
**pthread_detach()和pthread_join()就是控制子线程回收资源的两种不同的方式。**同一进程间的线程具有共享和独立的资源，其中共享的资源有堆、全局变量、静态变量、文件等公用资源。而独享的资源有栈和寄存器，这两种方式就是决定子线程结束时如何回收独享的资源。
>如果是joinable状态，则该线程结束后（通过pthread_exit结束或者线程执行体任务执行完毕）不会释放线程所占用堆栈和线程描述符（总计8K多）等资源，除非在主线程调用了pthread_join函数之后才会释放。pthread_join函数一般应用在主线程需要等待子线程结束后才继续执行的场景。(pthread_join是一个阻塞函数，调用方会阻塞到pthread_join所指定的tid的线程结束后才被回收，但是在此之前，调用方是霸占系统资源的。 )

>如果是unjoinable状态，则该线程结束后会自动释放占用资源。实现方式是在创建时指定属性，或者在线程执行体的最开始处添加一行：pthread_detach(pthread_self())；不会阻塞，调用它后，线程运行结束后会自动释放资源,后者非常方便。
总结：
- pthread_detach()即主线程与子线程分离，两者相互不干涉，子线程结束同时子线程的资源自动回收。

- pthread_join()即是子线程合入主线程，主线程会一直阻塞，直到子线程执行结束，然后回收子线程资源，并继续执行。


## 类单例 懒汉式、饿汉式
## 线程竞争

**测试不同的对象 扩充** （略微解决）

## thread_local 关键字
[示例学习](https://blog.csdn.net/zhizhengguan/article/details/109737834)



# C++语言类

## 可变参数

有时我们无法提前预知应该向函数传递几个实参。例如，我们想要编写代码输出程序产生的错误信息，此时最好用同一个函数实现该项功能，以便对所有错误的处理能够整齐划一。然而，错误信息的种类不同，所以调用错误输出函数时传递的实参也各不相同。编写变长参数的函数有几种方法：

### C方法：va_list

stdarg.h头文件提供了C语言中变长参数的功能，但用法较为复杂。
要使用C方法变长参数，首先在函数声明里用...声明列表（必须在最后，且不能只有...）：

```cpp
int f(int n, ...);//合法
int g(int n, ... int m);//不合法
int h(...)//不合法
```

在调用的时候，我们就可以传入变长参数：```f(3, 400, 500, 600);```
然后在函数定义里，声明`va_list`类型的变量（随意取名）：`va_list myargs;`
然后使用`va_start`将变长参数拷贝进来，（第二个参数通常是最后一个具名参数，代表长度）:`va_start(myargs, n);`
接下来，我们可以不断调用va_arg获取下一个参数;最后使用va_end清理结尾：va_end(myarg)

```cpp
va_arg(myargs, int); //获取下一个int
va_arg(myargs, double); //获取下一个double
//完整代码：
#include <stdarg.h>
int f(int n,...) {
    va_list myarg;
    va_start(myarg, 10);
    int ans(0);
    for (int i(0);i<n;i++) ans += va_arg(myarg, int); //仅支持int
    va_end(myarg);
    return ans;
}
```

从中就可以看出，这个变长参数列表是直接以获取二进制流，没有包含类型信息，所以做不到处理各种类型。上面的函数只能在传入32位数时工作，传入64位数或者浮点数就会截断成两个数再相加。所以C中的scanf printf两个函数必须传入格式化字符串指定类型，并且不能写错，不然就会有错误的结果。

### C++方法：使用initializer_list

initializer_list传参则要简单的多，首先这个东西自己就是一种模板容器，使用方法和vector类似。不过，它的元素值只作为参数传递，通常不能修改。有了这个东西，我们就可以把多个参数打包成一个参数传入。
![alt text](image-2.png)

```cpp
#include <initializer_list>
int max(std::initializer_list<int> li) {
    int ans = 1 << 31;
    for (auto x: li) ans = ans>x ? ans : x;
    return ans;
} 
int main() {
	printf("%d\n", max({1, 2, 3})); //加上大括号，作为整体调用
}
```

优点：很灵活，易于理解。
缺点：

- 只支持单一类型
- 只能读，不能写
- 要额外加括号，形式不统一

其实C++11以后标准库就有了变长max了，就是使用的这种括号形式。

### C++方法：使用可变参数模板

一个可变参数模板（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包(parameter packet)。存在两种参数包:模板参数包(template parameter packet)，表示零个或多个模板参数;函数参数包function parameterpacket)，表示零个或多个函数参数。
用下面的方式声明一个可变参数模板：

~~~cpp
template<class T, class... Args> //Args：“模板参数包”
void foo(const T &t, const Args&... test); //test：“一个参数包（含有0或多个参数）”
 
foo(i, s, 42, d); //包中有三个参数
foo(s, 42, "hi"); //包中有两个参数
foo(d, s); //包中有一个参数
foo("hi"); //空包
//如此，编译器会在编译器就实例化所有出现过的版本：

void foo(const int&,const string&,const int&,const double& );
void foo(const string&,const int&, const char [3]&);
void foo(const double&, const string&);
void foo(const char[3] &);
//模板通常采用递归方式展开：

template<class T>
void print(T &t) {cout << t <<'\n';}
 
template<class T, class... Args>
void print(T &t, Args&... rest) {
    cout << t << ' ';
    print(rest...); // 打印剩余参数，注意省略号必须有
}
~~~

在调用print时，首先调用变长版，然后递归调用print，直到剩下最后一个参数。由于Args也能使用零参数，就与第一个函数形成重载，此时会重载第一个更特化函数，结束递归。所以必须有第一个函数，否则会无限递归。
优点：

- 功能最强大，这里只列出入门知识，模板参数包还有非常多的用法。
- 编译时展开，效率高。
  缺点:
- 语法复杂繁琐，语义不清晰。省略号的位置我现在都记不清只能现查。更别说进阶语法。
- 更多是一种炫技。实际应用只需要最基本形式的变长模板就够了。

### std::function 与std::bind 的一些知识

/*指定std::function的可调用对象可以是 函数指针 重载了operator() 的类的对象等？

 * std::function 用于类的成员函数时，指定可调用对象的类型时首个参数为类的引用,或者指针
 * 使用std::bind 绑定类的成员函数的时候 也要注意首先指定一个参数为对象的指针
 * // 声明一个接受可变参数的模板函数
   template<typename... Args>
   void print(Args... args) {
    // 展开参数包并将参数传递给 std::cout
    (std::cout << ... << args);
    std::cout<< '\n'; // C++17 的折叠表达式
   }
 * */

## 可变参数模板的参数展开+可变类模板

一是利用递归进行逐级。展开这种方式原理是

先定义一个无模板参数的接口，

同时重载一个首参数独立模板类型，其余参数可变参数模板的接口

这样通过这个接口来处理可变参数模板，

然后产生递归效应。

```c++
template<typename... Types> //...可接纳的模板参数个数是0个及以上的任意数量，需要注意包括0个

template<typename Head, typename... Tail> //本质上，...可接纳的模板参数个数仍然是0个及以上的任意数量，但由于多了一个Head类型，由此该模板可以接纳1个及其以上的模板参数。

void print(){}

template<typename T,typename... Types>
void print(const T& firstArg,const Types&... args)
{
    std::cout<<firstArg<<" "<<sizeof...(args)<<std::endl;
    print(args...);
}

template<typename T>
T my_max(T value)
{
    return value;
}

template<typename T,typename... Args>
T my_max(T value,Types&... args)
{
    return std::max(value,my_max(args...));
}

```

还有一种是利用匿名数组初始化来展开的

```c++
template<typename... Args>
void print(Args... args) {
    int _[] = {(std::cout << args << " ", 0)...}; // 使用匿名数组展开参数
    (void)_; // 显式忽略返回值
    std::cout << std::endl; // 输出换行
}

```

逗号运算符展开

```c++
#include <iostream>

template <class ...Args>
void FormatPrint(Args... args)
{
   (void)std::initializer_list<int>{ (std::cout << "[" << args << "]", 0)... }; //这个表达式的值就是0,初始化列表保证其中的内容从左往右执行，args参数包会被逐步展开，表达式前的(void)是为了防止变量未使用的警告，运行过后我们就得到了一个N个元素为0的初始化列表，内容也被格式化输出了
   std::cout << std::endl;
}

int main(void)
{
   FormatPrint(1, 2, 3, 4);
   FormatPrint("good", 2, "hello", 4, 110);
   return 0;
}
```





类模板的使用

除了函数模板的使用外，类模板也可以使用不定参数的模板参数，最典型的就是`tuple`类了。其大致代码如下：

```c++
#include <iostream>

template<typename... Values> class tuple;
template<> class tuple<> {};

template<typename Head, typename... Tail>
class tuple<Head, Tail...>
  : private tuple<Tail...>
{
  typedef tuple<Tail...> inherited;
  public:
    tuple() {}
    tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...) {}
    Head& head() {return m_head;}
    inherited& tail() {return *this;}
  protected:
    Head m_head;
};

int main(int argc, char *argv[]) {
	tuple<int, float, std::string> t(1, 2.3, "hello");
	std::cout << t.head() << " " << t.tail().head() << " " << t.tail().tail().head() << std::endl;

	return 0;
}

//根据代码可以知道，tuple类继承除首之外的其他参数的子tuple类，以此类推，最终继承空参数的tuple类。继承关系可以表述为：
tuple<>
      ↑
tuple<std::string>
  string "hello"
      ↑
tuple<float, std::string>
  float 2.3
      ↑
tuple<int, float, std::string>
  int 1

//接下来考虑在内存中的分布，内存中先存储父类的变量成员，再保存子类的变量成员，也就是说，对象t按照内存分布来说；
┌─────────┐<---- 对象指针
|  hello  |
|─────────|
|  2.3    |
|─────────|
|  1      |
└─────────┘

//这时候就可以知道下一句代码的含义了： inherited& tail() {return *this;}
//tail()函数返回的是父类对象，父类对象和子类对象的内存起始地址其实是一样的，因此返回*this，再强行转化为inherited类型。
```

除了递归继承的方式外，也可以采用递归复合的方式：

```c++
template<typename... Values>class tup;
template<>class tup<>{}

template<typename Head,typename... Tail>
class tup<Head,Tail...>
{
public:
    typedef tup<Tail...> composited;
    tup(){}
    tup(Head v,Tail... vtail):m_head(v),m_tail(vtail...){}
    Head& head() {return m_head;}
    composited& tail() {return m_tail;}
protected:
    Head m_head;
    composited m_tail;
};
```

标准库的tuple

```c++
#include <iostream>
#include <tuple>

int main(int argc, char *argv[]) {
  std::tuple<int, float, std::string> t2(1, 2.3, "hello");
  std::get<0>(t2) = 4;                      // 修改tuple内的元素
  std::cout << std::get<0>(t2) << " " << std::get<1>(t2) << " " << std::get<2>(t2) << std::endl;    // 获取tuple内的元素

  auto t3 = std::make_tuple(2, 3.4, "World");         // make方法生成tuple对象
  
  std::cout << std::tuple_size<decltype(t3)>::value << std::endl;    // 获取tuple对象元素的个数
  std::tuple_element<1, decltype(t3)>::type f = 1.2;          // 获取tuple对象某元素的类型

	return 0;
}

```



### 



## std::thread

[C++11 多线程（std::thread）详解_c++11线程使用-CSDN博客](https://blog.csdn.net/sjc_0910/article/details/118861539)

## C++协程 (学不懂) 看两个网站 [1](https://www.cnblogs.com/blizzard8204/p/17563217.html) [2](https://zhuanlan.zhihu.com/p/355100152))

协程就是一个可以**挂起(suspend)**和**恢复(resume)**的函数(但无论如何不能是 main 函数)。你可以暂停协程的执行，去做其他事情，然后在适当的时候恢复到暂停的位置继续执行。**协程让我们使用同步方式写异步代码**。

- **`co_await`**：用于挂起协程的执行，等待某个异步操作完成。

- **`co_return`**：用于返回结果，并结束协程的执行。

- **`co_yield`**：用于生成值，挂起协程，并在下次恢复时继续执行。

C++协程一般这个样子：

```c++
struct ReturnObject {
    struct promise_type {
        ReturnObject get_return_object() { return {}; }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() { return {}; }
        void unhandled_exception() {}
    };
};

struct Awaitable {
    std::coroutine_handle<> *hp_;
    constexpr bool await_ready() const noexcept { return false; }
    void await_suspend(std::coroutine_handle<> h) { *hp_ = h; }
    void await_resume() noexcept {
        std::cout << "Event signaled, resuming." << std::endl;
    }
};

ReturnObject counter(std::coroutine_handle<> *continuation_out) {
    Awaitable a{continuation_out};
    for (unsigned i = 0;; ++i) {
        co_await a;
        std::cout << "counter: " << i << std::endl;
    }
}
```

涉及三个概念：`promise_type`,`Awaitable`,`std::coroutine_handle<>`

### promise

C++ 协程的**返回类型**必须是 `promise_type`，`promise_type` 是一个 interface，你可以用它来控制协程，在协程的[生命周期](https://zhida.zhihu.com/search?content_id=167040569&content_type=Article&match_order=1&q=生命周期&zhida_source=entity)中注入自定义行为：

- `get_return_object`： 控制协程的返回对象
- `initial_suspend`：在协程开始的时候挂起
- `final_suspend`：在协程结束的时候挂起

协程的生命周期如下，用户自定义的函数 `<function-body>` 被包裹在下面的[伪代码](https://zhida.zhihu.com/search?content_id=167040569&content_type=Article&match_order=1&q=伪代码&zhida_source=entity)中

```cpp
{
   promise-type promise promise-constructor-arguments ;
   try {
      co_await promise.initial_suspend() ;
      <function-body>
   } catch ( ... ) {
      if (!initial-await-resume-called)
         throw ;
      promise.unhandled_exception() ;
   }
final-suspend :
   co_await promise.final_suspend() ;
}

// coroutine 被销毁
```

可以看到，`initial_suspend` 会在进入协程(也就是函数)之前执行，`final_suspend` 会在协程返回之前执行。

如果 `final_suspend` 真的挂起了协程，那么作为协程的调用者，你需要手动的调用 destroy 来释放协程；如果 `final_suspend` 没有挂起协程，那么协程将自动销毁。先记住这句话，在后面还会提到。

除此之外，Promise 还有一些其它责任：

- `return_void()`/`return_value()`/`yield_value()` 方法: 用来控制 `co_return` 和 `co_yield`的行为；
- `unhandled_exception()` 处理异常
- 创建和销毁协程的 `stackframe`
- 处理 `stackframe` 创建可能发生的异常

stackframe ：函数运行时占用的内存空间，是栈上的数据集合，它包括：

- 局部变量
- 被子程序修改的寄存器的保存副本可能需要恢复
- 参数的参数
- 返回地址

### **Awaitable**

第二个概念是 `Awaitable`，`Awaitable` 负责管理协程挂起时的行为。

一个 Awaitable 对象可以成为 `co_await` 调用的对象。Awaitable 拥有以下方法：

- `await_ready()`：是否要挂起，如果返回 true，那么 `co_await` 就不会挂起函数；
- `await_resume()`：`co_await` 的返回值，通常返回空；
- `await_suspend()`：协程挂起时的行为；

> 可以在 `await_suspend` 中实现 `await_ready` 的效果，例如直接不挂起当前的协程，但在调用 `await_suspend` 之前，编译器必须将所有状态捆绑到协程的 `stackframe` 中，这会更耗时。

有时候我们的协程并不需要自定义复杂的行为，C++ 提供了两个默认的 `Awaitable`：

```cpp
namespace std {
    struct suspend_never {
        constexpr bool await_ready() const noexcept { return true; }
        constexpr void await_suspend(coroutine_handle<>) const noexcept {}
        constexpr void await_resume() const noexcept {}
    };
    
    struct suspend_always {
        constexpr bool await_ready() const noexcept { return false; } 
        constexpr void await_suspend(coroutine_handle<>) const noexcept {}
        constexpr void await_resume() const noexcept {}
    };
}
```

`suspend_always::await_ready()` 总是返回 false，而 `suspend_always::await_ready()` 总是返回 true。其他的方法都是空的，没有任何作用。

如果没有其它多余的行为，我们可以在函数中直接调用 `co_await std::suspend_always{}` 来挂起一个函数。

### **Coroutine Handle**

`co_await` 挂起函数，并创建了一个可调用对象，这个对象可以用来恢复Hanns乎的执行。这个可调用对象的类型就是 `std::coroutine_handle<>`，最常用的两个方法是：

- `handle.resume()`：恢复协程的执行；
- `handle.destroy()`：销毁协程；

`Coroutine Handle` 很像指针，我们可以复制它，但析构函数不会释放相关状态的内存。为了避免[内存泄漏](https://zhida.zhihu.com/search?content_id=167040569&content_type=Article&match_order=1&q=内存泄漏&zhida_source=entity)，一般要调用 `handle.destroy()` 来释放（尽管在某些情况下，协程会在完成后自行销毁——前文有提到）。同样像指针一样，一旦销毁了一个 `Coroutine Handle` ，指向同一个协程的另一个 `Coroutine Handle` 将指向垃圾，并在调用时表现出[未定义行为](https://zhida.zhihu.com/search?content_id=167040569&content_type=Article&match_order=1&q=未定义行为&zhida_source=entity)。

## union

1.    如果非静态(non-static)成员带有非平凡的特殊(non-trivial special)成员函数(自定义的：复制/移动构造函数，复制/移动赋值函数，析构函数)，则该union类的默认相关的复制/移动构造函数、复制/移动赋值函数、析构函数都会被删除，如果需要的话，要求用户自己定义实现，如果用户没有自己定义，则不能进行相关的复制/移动操作
2.    如果非静态(non-static)成员带有非平凡的特殊(non-trivial special)构造函数(自定义的构造函数)，则该union类的默认构造函数会被删除，如果需要的话，要求用户自己定义实现，如果用户没有自己定义，则不能该union类不能进行实例化。
3.    至多一个变体成员能拥有默认成员初始化值
4.    不能有静态成员数据，但是可以有静态成员函数
5.    全部成员的访问控制都是public
> 第1、2点的意思是，如果成员数据类型是非平凡的(non-trivial)，则union类需要定义相关的构造函数、复制函数、移动构造、移动赋值函数、析构函数等。
~~~c++
union A {
  int a;
  double b;
  std::string c;
  A() : c("111") {} // 因为std::string拥有是非平凡的的数据类型，
  ~A() {}           // 则A必须自定义构造函数和析构函数，否则无法进行实例化
                    // 如果想实现复制语义，还得自定义复制(构造)函数
};
~~~
>第3点的意思是：
~~~c
union A {
  int a;
  double b;
  std::string c = "abc"; // 只有一个成员数据能拥有这种初始化值
  ~A(){};
};
~~~
## 智能指针
 shared_ptr、unique_ptr、weak_ptr、auto_ptr
### shared_ptr
实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象
1) 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针；
2) 每次创建类的新对象时，初始化指针并将引用计数置为1；
3) 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；
4) 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；
5) 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。
>注意：引用计数机制涉及两种不同的计数器。
 强引用计数：
> - 定义：强引用计数记录有多少个 shared_ptr 实例指向某个对象。
> - 作用：当强引用计数归零时，即当最后一个指向该对象的 shared_ptr 被销毁、重置或重新分配时，指向的对象会被销毁。
> - 计数增加：每当创建一个新的 shared_ptr，并且它指向相同的对象时，强引用计数会增加。
> * 计数减少：每当 shared_ptr 被销毁、重置或其指向对象发生变化时，强引用计数会减少
> 
> 弱引用计数（Weak Reference Count）
> * 定义：弱引用计数记录有多少个 weak_ptr 实例指向某个对象。
> * 作用：弱引用计数不会影响对象的生命周期，也就是说，weak_ptr 不会延长对象的存活时间。弱引用计数主要用于管理控制块，确保即使对象被销毁，weak_ptr 仍然可以安全使用。
> * 计数增加：每当创建一个新的 weak_ptr 指向某个对象时，弱引用计数会增加。
> * 计数减少：当 weak_ptr 被销毁、重置或指向不同对象时，弱引用计数减少。
### unique_ptr
unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。
所以unique_ptr不支持普通的拷贝和赋值操作,局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）。
### weak_ptr
引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。
如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。
## 零拷贝

## c++返回值优化
* 对于RVO,对于临时对象（也就是右值对象）编译器不会在内存中创建它， 什么时候创建它呢？ 当把它赋值给一个左值对象时才会创建这个对象。
所以呢， 对于一个函数返回一个函数内的局部的临时对象时，编译器优化之后相当于在函数的调用点处才会创建这个对象。
* 对于NRVO，在函数的调用点处，先创建这个对象，然后通过对象指针传递到函数内，对该对象进行相关操作。 
## 预声明作用
```cpp
class CXmlNodeList;//预声明，告知编译器，该定义会提前使用
//提前使用这种类的使用形式只有两种：引用、指针，
class CXmlNode
{
public:
    //...
    void func(CXmlNodeList& s1,CXmlNodeList* ps2);
};
```
## 非虚函数实现多态的一个实例
```cpp
template<class T>
class Edoyun
{
public:
    void show()
    {
        T* p = static_cast<T*>(this);
        p->Name();
    }
protected:
    void Name() { std::cout << "Edoyun" << std::endl; } //不是虚函数
};

class Sub :public Edoyun<Sub>
{
public:
    void Name() { std::cout << "Sub" << std::endl; }
};

class Sub2 :public Edoyun<Sub2>
{
public:
	void Name() { std::cout << "Sub2" << std::endl; }
};

int main()
{
    Sub sub;
    Sub2 sub2;
    sub.show();
    sub2.show();
    return 0;
}
```
编译时确定函数调用而不是运行时的多态。也减少了虚函数表的消耗。
## std::condition_variable std::unique_lock
在 C++ 中，std::unique_lock 是一个管理互斥锁（mutex）的辅助类，它提供了比 std::lock_guard 更高的灵活性。std::unique_lock 允许开发者在构造时或者构造后获取锁，并且在作用域内可以手动获取锁和释放锁。当作用域结束时，如果已经获取了锁，则 std::unique_lock 会自动释放锁。
[简易简介](https://zhuanlan.zhihu.com/p/340348726) [函数介绍](https://blog.csdn.net/qq_38210354/article/details/107168532)

std::condition_variable 是 C++11 中引入的一个同步原语，用于在多线程程序中进行线程间的同步。它允许一个或多个线程在某个条件为真之前挂起（等待），直到另一个线程修改了条件并通知 std::condition_variable。
基本概念和使用方法
std::condition_variable 需要与 std::unique_lock<std::mutex> 一起使用，以便在等待条件时释放互斥锁，并在条件满足后重新获取互斥锁。它提供了 wait、notify_one 和 notify_all 方法来实现线程间的等待和通知机制。
wait 方法使当前线程阻塞，直到条件变量被另一个线程通过 notify_one 或 notify_all 方法唤醒。
notify_one 方法唤醒一个等待条件变量的线程。
notify_all 方法唤醒所有等待条件变量的线程。

- 使用condition_variable时，必须确保在等待之前获取互斥锁，并且在唤醒后释放互斥锁。
- wait、wait_for和wait_until函数都会释放互斥锁，然后在等待期间重新获取它。
- notify_one唤醒一个等待的线程，而notify_all唤醒所有等待的线程。
```cpp
#include <iostream>                // std::cout
#include <thread>                // std::thread, std::this_thread::yield
#include <mutex>                // std::mutex, std::unique_lock
#include <condition_variable>    // std::condition_variable

std::mutex mtx;
std::condition_variable cv;

int cargo = 0;
bool shipment_available()
{
    return cargo != 0;
}

// 消费者线程.
void consume(int n)
{
	std::cout<<__LINE__<<std::endl;
    for (int i = 0; i < n; ++i) {
        std::unique_lock <std::mutex> lck(mtx);
        cv.wait(lck, shipment_available);
        std::cout << "cargo : "<<cargo << '\n';
        cargo = 0;
    }
	std::cout<<__LINE__<<std::endl;
}

int main()
{
    std::thread consumer_thread(consume, 10); // 消费者线程.
	std::cout<<__LINE__<<std::endl;
    // 主线程为生产者线程, 生产 10 个物品.
    for (int i = 0; i < 10; ++i) {
        while (shipment_available())
            std::this_thread::yield(); //它允许当前线程主动放弃其CPU时间片，这样其他线程就有机会被执行。这个函数的调用会导致当前线程进入就绪状态，等待操作系统重新进行线程调度。
        std::unique_lock <std::mutex> lck(mtx);
        cargo = i + 1;
		std::cout<<"mian cargo : "<<cargo<<std::endl;
        cv.notify_one();
    }

    consumer_thread.join();

    return 0;
}
```

## 线程 线程池
用到了临界区域。
### 临界区域(也叫关键代码段) 仅用于Windows 效率高于互斥体 有系统来控制
工作在用户方式下。它是指一个小代码段，在代码能够执行前，它必须独占对某些资源的访问权。
使用eg:
1.     初始化关键代码段
       调用InitializeCriticalSection函数初始化一个关键代码段。InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
       该函数只有一个指向CRITICAL_SECTION结构体的指针。在调用InitializeCriticalSection函数之前，首先需要构造一个CRITICAL_SCTION结构体类型的对象，然后将该对象的地址传递给InitializeCriticalSection函数。

2.     进入关键代码段
       VOID WINAPI EnterCriticalSection(
        _Inout_ LPCRITICAL_SECTION lpCriticalSection
        );
       调用EnterCriticalSection函数，以获得指定的临界区对象的所有权，该函数等待指定的临界区对象的所有权，如果该所有权赋予了调用线程，则该函数就返回；否则该函数会一直等待，从而导致线程等待。

3.	   退出关键代码段 VOID WINAPI LeaveCriticalSection(_Inout_     LPCRITICAL_SECTION lpCriticalSection);
        线程使用完临界区所保护的资源之后，需要调用LeaveCriticalSection函数，释放指定的临界区对象的所有权。之后，其他想要获得该临界区对象所有权的线程就可以获得该所有权，从而进入关键代码段，访问保护的资源。

4.	   删除临界区 WINBASEAPI VOID WINAPI DeleteCriticalSection(
        _Inout_ LPCRITICAL_SECTION lpCriticalSection
        );
          当临界区不再需要时，可以调用DeleteCriticalSection函数释放该对象，该函数将释放一个没有被任何线程所拥有的临界区对象的所有资源。

### 互斥体 无视平台 在linux下效率更高。
属于内核对象，它能够确保线程拥有对单个资源的互斥访问权。
互斥对象包含一个使用数量，一个线程ID和一个计数器。其中线程ID用于标识系统中的哪个线程当前拥有互斥对象，计数器用于指明该线程拥有互斥对象的次数。
简易的使用步骤：eg：Windows系统
1. 创建互斥对象：调用函数CreateMutex。调用成功，该函数返回所创建的互斥对象的句柄。
2. 请求互斥对象所有权：调用函数WaitForSingleObject函数。线程必须主动请求共享对象的所有权才能获得所有权。
3. 释放指定互斥对象的所有权：调用ReleaseMutex函数。线程访问共享资源结束后，线程要主动释放对互斥对象的所有权，使该对象处于已通知状态。

### 原子操作 保护的是操作 
### 额外讲解一种 事件对象
事件对象也属于内核对象，它包含以下三个成员：
- 使用计数；
- 用于指明该事件是一个自动重置的事件还是一个人工重置的事件的布尔值；
- 用于指明该事件处于已通知状态还是未通知状态的布尔值。

事件对象有两种类型：人工重置的事件对象和自动重置的事件对象。这两种事件对象的区别在于当人工重置的事件对象得到通知时，等待该事件对象的所有线程均变为可调度线程；而当一个自动重置的事件对象得到通知时，等待该事件对象的线程中只有一个线程变为可调度线程。
简易使用步骤
1.     创建事件对象
       调用CreateEvent函数创建或打开一个命名的或匿名的事件对象。
2.     设置事件对象状态
       调用SetEvent函数把指定的事件对象设置为有信号状态。
3.     重置事件对象状态
       调用ResetEvent函数把指定的事件对象设置为无信号状态。
4.     请求事件对象
       线程通过调用WaitForSingleObject函数请求事件对象。
### 线程同步之信号量
内核对象的状态：
触发状态(有信号状态)，表示有可用资源。
未触发状态（无信号状态），表示没有可用资源
信号量的组成：
1.     计数器：该内核对象被使用的次数
1.     最大资源数量：标识信号量可以控制的最大资源数量（带符号的32位）
2.     当前资源数量：标识当前可用资源的数量（带符号的32位）。即表示当前开放资源的个数（注意不是剩下资源的个数），只有开放的资源才能被线程所申请。但这些开放的资源不一定被线程占用完。比如，当前开放5个资源，而只有3个线程申请，则还有2个资源可被申请，但如果这时总共是7个线程要使用信号量，显然开放的资源5个是不够的。这时还可以再开放2个，直到达到最大资源数量。
>信号量与互斥量不同的地方是，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源。

### 比较
各种线程同步的比较总结
windows线程同步的方式主要有四种：互斥对象Mutex、事件对象event和关键代码段criticalSection，信号量
对于上面介绍的三种线程同步的方式，它们之间的区别如下所述：
- 互斥对象和事件以及信号量都属于内核对象，利用内核对象进行线程同步时，速度较慢，但利用互斥对象和事件对象这样的内核对象，可以在多个进程中的各个线程间进行同步。
- 关键代码段工作在用户方式下，同步速度较快，但在使用关键代码段时，很容易进入死锁状态，因为在等待进入关键代码段时无法设定超时值。
- 用户级别的：关键代码段，只能本进程中
- 内核级别的：互斥量/事件/信号量，可以跨进程

通常，在编写多线程程序并需要实现线程同步时，首选关键代码段，由于它的使用比较简单，如果是在MFC程序中使用的话，可以在类的构造函数Init中调用InitializeCriticalSection函数，在该类的析构函数中调用DeleteCriticalSection函数，在所需保护的代码前面调用EnterCriticalSection函数，在访问完所需保护的资源后，调用LeaveCriticalSection函数。可见，关键代码段在使用上是非常方便的，但有几点需要注意：
> - 在程序中调用了EnterCriticalSection后，要相应的调用LeaveCriticalSection函数，否则其他等待该临界区对象所有权的线程将无法执行。
> - 如果访问关键代码段时，使用了多个临界区对象，就要注意防止线程死锁的发生。另外，如果需要在多个进程间的各个线程间实现同步的话，可以使用互斥对象和事件对象或者信号量。

|比较|互斥量 Mutex|事件对象 Event|信号量对象 Semaphore|关键代码段（临界区）CriticalSection|
|:--|:--|:--|:--|:--|
|是否为内核对象|是|是|是|否|
|速度|	较慢|	较慢|	较慢|	快|
|多个进程种的线程同步|支持|支持|支持|不支持|
|发生死锁|否|否|否|是|
|组成|一个线程ID：用来标识哪个线程当前拥有该互斥量；一个计数器：用于指明该线程拥有互斥对象的次数|一个使用计数；一个布尔值：用来标识该事件是自动重置还是人工重置；一个布尔值：表示用于指明该事件处于已通知状态（有信号）还是未通知状态（无信号）|一个使用计数；最大资源数量；标识当前可用资源的数量|一个小代码段；在代码能够执行钱，它必须独占对某些资源的访问权|
|相关函数|	CreateMutex; WaitForSingleObjects; 被保护的内容ReleaseMutex|CreateEvent ResetEvent WaitForSingleObject 保护内容 SetEvent|	CreateSemaphore WaitForSingleObject 被保护的内容 ReleaseSemaphore|InitializeCriticalSection EnterCriticalSection 被保护的内容 LeaveCriticalSection DeleteCriticalSection|
|注意事项|谁拥有互斥对象谁释放；如果多次在同一个线程请求同一个互斥量，那么需要多次调用releaseMutex|	为了实现线程间的同步，不应该使用人工重置，应该把第二个参数设置为false，设置为自动重置|	它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目|	防死锁：使用多个临界区对象g_csA g_csB。|
|类比|	一把钥匙|	一把钥匙|	停车场与保安|	电话亭|

## 构造函数和析构函数 涉及到子类的调用顺序是怎样的，为什么是相反的，尝试从虚指针的构造过程说明，构造函数和析构函数能否为虚函数的原因？

#### 1. **构造顺序的原因**：

- **依赖关系**：派生类在构造时需要依赖其基类的成员和行为，因此必须先初始化基类。
- **继承结构**：基类在派生类之前被构造，确保派生类可以在构造函数中使用基类中的资源和功能。

#### 2. **析构顺序的原因**：

- **清理顺序**：派生类可能会在析构函数中使用基类提供的资源，因此在析构时先销毁派生类，最后销毁基类。
- **资源释放**：为了避免使用已经销毁的对象或未释放的资源，析构顺序是先派生后基类，这样可以确保对象按依赖关系反向释放资源。

虚指针的构造过程是在实例化对象的时候，在构造函数执行时会对虚表指针进行初始化，并存储在对象内存布局的最前面。所以构造函数不能是虚函数，因为还没有虚表指针就无法调用虚函数。

**析构函数一般建议声明为虚析构，基类声明了虚析构函数，派生类的析构函数自动为虚析构**。[C++基类的析构函数为何要声明为虚函数 - 知乎](https://zhuanlan.zhihu.com/p/148290103)

## std::atomic

C++中原子变量（atomic）是一种多线程编程中常用的同步机制，它能够确保对共享变量的操作在执行时不会被其他线程的操作干扰，从而避免竞态条件（race condition）和死锁（deadlock）等问题。

原子变量可以看作是一种特殊的类型，它具有类似于普通变量的操作，但是这些操作都是原子级别的，即要么全部完成，要么全部未完成。C++标准库提供了丰富的原子类型，包括整型、指针、布尔值等，使用方法也非常简单，只需要通过std::atomic<T>定义一个原子变量即可，其中T表示变量的类型。

[C++原子变量atomic详解 - 知乎](https://zhuanlan.zhihu.com/p/599202353)

## 左值 与 右值 移动语义

移动语义与右值是用来优化对象的转移操作，从而避免不必要的拷贝，提高程序性能。std::move 是一个标准库函数，用于将左值转换为右值引用，以便启用移动语义。

### 移动语义

移动语义通过将资源从一个对象“移动”到另一个对象，而不是复制资源，从而提高了程序的效率。移动语义在对象的移动构造函数和移动赋值运算符中实现。

### **右值引用**

右值引用（rvalue references）是 C++11 引入的新类型，表示一个只能绑定到右值（临时对象）的引用。使用右值引用可以避免不必要的拷贝操作，从而提高程序的性能。

一个对象在使用`std::move`移动语义后，**std::move**本身并不会对源**对象**进行任何实际的修改，它仅仅是将一个左值转换为右值，使得可以将资源从源**对象**“移动”到新对象。 在**std::move**之后，源**对象**仍然是一个完全有效的C++对象，可以进行赋值、销毁等操作。 然而，由于资源已经被移动，源**对象**的状态可能会变得不可预测。 在某些情况下，源对象可能会被置于一个特殊的状态，例如，某些成员可能被设置为nullptr或默认值。 这是为了优化性能。

### `emplace_back`与`push_back`区别：

将 `emplace_back()` 和 `push_back()` 中区别最大的程序拎出来看：

```c++
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                                 std::forward<_Args>(__args)...); // emplace_back()
_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                                 __x);                            // push_back()

template<typename _Tp>
constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept {
    return static_cast<_Tp &&>(__t);
}
```

对于 `std::forward()` 函数而言，本质上是一个类型转换函数，它的声明函数如下所示：

**在强制类型转换中，将参数 `__t` 传递给对应类 `_Tp` 的构造函数，然后调用了该类的构造函数从而完成对象创建过程。**

因此，在 `emplace_back()` 函数中，是***支持直接将构造函数所需的参数传递过去，然后构建一个新的对象出来，然后填充到容器尾部的。***

直观的区别：例如可能调用到的构造函数不同：

```c++
class Person {
    int _age;

public:
    Person(int age) : _age(age) {
        cout << "Construct a person." << _age << endl;
    }

    Person(const Person &p) : _age(p._age) {
        cout << "Copy-Construct" << _age << endl;
    }

    Person(const Person &&p) noexcept: _age(p._age) {
        cout << "Move-Construct" << _age << endl;
    }
};

//push_back
int main() {
    using namespace std;
    vector<Person> person;
    auto p = Person(1); // >: Construct a person.1
    person.push_back(p);
    /**
     * >: Copy-Construct1 因为容器扩容，需要把前面的元素重新添加进来，因此需要拷贝
     */
}
//emplace_back
int main() {
    using namespace std;
    vector<Person> person;
    auto p = Person(1); // >: Construct a person.1
    person.emplace_back(move(p)); // >: Move-Construct1
    person.emplace_back(2);
    /**
     * >: Construct a person.2  // 构建一个新的元素
     * >: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &&p)
     */
}
```

可以看到直接使用**构造参数列表**来添加元素的方法，它会使用到了移动构造函数 `move` 。这也是 `emplace_back()` 方法的一大特色。

内存优化主要体现在使用了**就地构造（直接在容器内构造对象，不用拷贝一个复制品再使用）+强制类型转换**的方法来实现，在运行效率方面，由于省去了拷贝构造过程，因此也有一定的提升。

## 动态加载

### 动态加载 Windows API 函数

```c++
HMODULE (*MyLoadLibraryA)(_In_ LPCSTR lpLibFileName)=NULL;
using MyGetProcAddress_=FARPROC (*)(_In_ HMODULE ,_In_ LPCSTR);
MyGetProcAddress_ MyGetProcAddress=NULL;
VOID (* myExitProcess)(UINT uExitCode);
static class StaticData
{
   public:
    StaticData()
    {
         MyLoadLibraryA = reinterpret_cast<HMODULE(*)(LPCSTR)>(LoadLibraryA); //LoadLibraryA：将指定的模块加载到调用进程的地址空间中。
        MyGetProcAddress = reinterpret_cast<FARPROC(*)(HMODULE, LPCSTR)>(GetProcAddress);//GetProcAddress：从指定的动态链接库 (DLL) 检索导出函数 (也称为过程) 或变量的地址。

    }
}_;

/*通过创建一个静态匿名对象 _，在程序启动时自动执行 StaticData 的构造函数。这样就可以在程序启动时立即初始化 MyLoadLibraryA 和 MyGetProcAddress 函数指针。
使用匿名对象的一个原因是确保这些函数指针在程序的任何地方都可以使用，而不需要显式地调用初始化代码。这是一种设计模式，利用静态对象的构造函数实现全局初始化。
*/
/*
这段代码通过定义一个静态类和匿名对象 _，在程序启动时自动初始化全局函数指针 MyLoadLibraryA 和 MyGetProcAddress。
这种方式确保了这些函数指针在程序的任何地方都可以安全地使用，而不需要额外的初始化代码。
*/
```

代码的初始部分通过 **静态构造函数** 和 **函数指针** 的方式，动态加载了 Windows API 函数 `LoadLibraryA` 和 `GetProcAddress`：

**功能：**

- 通过动态方式（而非直接使用导入符号）获取 `LoadLibraryA` 和 `GetProcAddress` 的地址。
- 在运行时使用 `MyLoadLibraryA` 和 `MyGetProcAddress` 调用 API，而不是直接依赖静态链接。

**目的：**

- **规避检测或限制：** 动态加载常用于规避某些安全检测（例如杀毒软件或逆向工程），因为没有直接导入符号，难以通过静态分析发现。
- **灵活性：** 可以动态决定加载哪些 DLL 或调用哪些函数。

### 动态还原字符串

代码将目标函数名 `ExitProcess` 和 DLL 名 `Kernel32.dll` 进行了某种加密，并在运行时还原：

```c++
/*QStatusCheck 类：用于检查某个状态（登录状态），并在状态不符合预期时终止进程。
动态库加载和函数指针：实现了动态加载库和获取函数地址，增加了代码的隐蔽性和灵活性。
字符数组解码：通过特定的加减运算，还原出实际使用的函数名和 DLL 名称。*/

QStatusCheck::QStatusCheck(QObject* parent) : QThread(parent)  //线程函数，不会干扰主线程
{
    //             ExitProcess
    //             +-+-+-+-+-+
    //             BA987654321
    char data[] = "PnrlWlt_hqt";//"ExitProcess";
    //            Kernel32.dll
    //            +-+-+-+-+-+-
    //            CBA987654321
    char dll[] = "WZ|eme9-2ank";
    for(int i = 0; i < 11; i++)
    {
        //还原ExitProcess
        if(i % 2 == 0)
        {
            data[i] -= (11 - i);
        }
        else
        {
            data[i] += (11 - i);
        }
    }
    for(int i = 0; i < 12; i++)
    {
        //还原Kernel32.dll
        if(i % 2 == 0)
        {
            dll[i] -= (12 - i);
        }
        else
        {
            dll[i] += (12 - i);
        }
    }
    //动态调用 ExitProcess
    HMODULE hdll = MyLoadLibraryA(dll);
    myExitProcess = (VOID(*)(UINT))MyGetProcAddress(hdll, data); //？使用动态加载的形式是没有导入符号的
}
```

**功能：**

- 将加密的字符串还原为明文：
  - `data` 最终还原为 `"ExitProcess"`;
  - `dll` 最终还原为 `"Kernel32.dll"`.

**目的：**

- **避免静态字符串分析：** 直接包含敏感字符串（如函数名和 DLL 名）可能会被逆向工程或检测工具轻易发现，因此加密后运行时再解密。

**过程：**

- 使用动态加载的方式，加载 `Kernel32.dll`；
- 然后通过 `MyGetProcAddress` 获取 `ExitProcess` 的函数地址；
- 将其赋值给 `myExitProcess`，后续可以直接调用。

**特点：**

- 因为没有静态导入 `Kernel32.dll` 和 `ExitProcess`，这部分逻辑不会被工具直接分析到，增加了代码隐蔽性。

### 登录状态检查线程

```c++
void QStatusCheck::run() {
    m_status = LOGIN_STATUS;
    if (m_status == false) {
        myExitProcess(0); // 调用动态加载的 ExitProcess 退出程序
        qDebug() << __FILE__ << __LINE__ << LOGIN_STATUS << m_status;
        abort();
        exit(0);
    }
}

```

**逻辑：**

- 定义了一个成员变量 `m_status`，从全局变量 `LOGIN_STATUS` 获取登录状态。
- 如果未登录 (`LOGIN_STATUS == false`)，则调用动态加载的 `ExitProcess(0)` 强制退出程序。

**行为：**

- 强制终止进程，确保程序无法继续运行；
- 调用 `qDebug` 输出一些调试信息（可能用于开发测试，但在实际运行时无太大意义）。

**特点：**

- 多次调用退出方法（`myExitProcess(0)`、`abort()`、`exit(0)`），确保程序无论如何都会终止。

### 代码的潜在用途

这段代码通常出现在以下场景：

1. 反破解或反调试：
   - 加密字符串和动态加载 API 是典型的反调试手段，用于规避静态分析和调试工具的检测。
   - 如果检测到某种非法状态（如未登录），立即终止程序运行。
2. 恶意程序：
   - 动态加载关键函数，可能用于隐藏恶意行为。
   - 加密敏感字符串，规避杀毒软件或逆向分析。
3. 合法用途：
   - 某些安全性要求高的程序可能使用类似技术保护关键逻辑。

# 数据结构

常见数据结构：

## 矩阵

存储稀疏矩阵时，由于大部分元素为零，使用专门的格式可以显著节省存储空间和提高计算效率。

1. **坐标列表 (COO)**

- **描述**：以三个数组来存储非零元素的行索引、列索引和对应的值。
- **优点**：简单且易于构建，适合用于构造矩阵。
- **缺点**：不适合高效的矩阵运算。

2. **压缩稀疏行 (CSR)**

- **描述**：使用三个数组：`values`（非零值），`column_indices`（对应列索引），`row_ptr`（行起始位置）。
- **优点**：存储紧凑，支持高效的矩阵-向量乘法。
- **缺点**：更新操作（如添加新元素）较慢。

3. **压缩稀疏列 (CSC)**

- **描述**：类似于CSR，但以列为单位进行存储。使用`values`（非零值），`row_indices`（对应行索引），`col_ptr`（列起始位置）。
- **优点**：适合快速的列访问。
- **缺点**：更新操作较慢。

[稀疏矩阵概念及简单实现-CSDN博客](https://blog.csdn.net/yhb1047818384/article/details/78996906)

## 堆排序



## 二叉树

### 平衡二叉树

### n 层平衡二叉树节点数

在一棵高度为 `n` 的平衡二叉树中：

- 最少节点数

  ：对于一棵平衡二叉树，最少节点数可以用递归关系来表示：

  - `N(n) = N(n-1) + N(n-2) + 1`，其中 `N(0) = 0` 和 `N(1) = 1`。
  - 实际上，这个递归关系与斐波那契数列相似。

- 最多节点数

  ：对于一棵高度为 `n `的平衡二叉树，最多节点数与普通的满二叉树一样：

  - `N(n) = 2^n - 1`。



## 链表

### 双向链表反转

**双向链表反转**，构建链表加实现反转。原地直接反转

```c++
#include <bits/stdc++.h>

using namespace std;

struct Node
{
    int data;
    Node* next;
    Node* prev;
};

void reverse_(Node** head)
{
    Node* temp= nullptr;
    Node* currnet=*head;
    //交换每个节点的前驱和后继指针
    while(currnet!= nullptr)
    {
        temp=currnet->prev;
        currnet->prev=currnet->next;
        currnet->next=temp;
        currnet=currnet->prev;
    }
    //修改头指针，即首元素的指针
    if(temp!= nullptr)
    {
        *head=temp->prev;
    }
}

//插入新节点到头部
void push_(Node** head,int newdata)
{
    Node* newNode=new Node();
    newNode->data=newdata;
    newNode->next=*head;
    newNode->prev= nullptr;
    if(*head!= nullptr)
    {
        (*head)->prev=newNode;
    }
    (*head)=newNode;
}

void print_List(Node* head)
{
    while(head!= nullptr)
    {
        cout<<" "<<head->data<<" ";
        head=head->next;
    }
    cout<<endl;
}

int main()
{
    Node* head= nullptr;
    push_(&head,0);
    push_(&head,1);
    push_(&head,2);
    push_(&head,3);
    push_(&head,4);
    push_(&head,5);
    cout<<"Original DLL is:"<<endl;
    print_List(head);
    reverse_(&head);
    cout<<"Reveersed DLL is: "<<endl;
    print_List(head);
    return 0;
}
```

### 线段树

[线段树（以区间求和为例）_线段数区间求和代码-CSDN博客](https://blog.csdn.net/royalfu/article/details/105799921?spm=1001.2014.3001.5501)

```c++
#include <iostream>
#include <bits/stdc++.h>
using namespace std;

vector<int> value;
vector<int> num;
void segment_tree(int n,vector<int>& v)
{
    value.resize(4*n);
    num.resize(n);
    for (int i=0;i<n;i++)
        num[i]=v[i];
}

void buildtree(int pos,int left,int right)
{
    if (left==right)
    {
        value[pos]=num[left];
        return;
    }
    int mid=(left+right)/2;
    buildtree(pos*2+1,left,mid);
    buildtree(pos*2+2,mid+1,right);
    value[pos]=value[pos*2+1]+value[pos*2+2];
}

void update(int index,int v,int left,int right,int pos)
{
    if (left==right&&index==left)
    {
        value[pos]=v;
        return;
    }
    int mid=(left+right)/2;
    if (index<=mid)
        update(index,v,left,mid,pos*2+1);
    else
        update(index,v,mid+1,right,pos*2+2);
    value[pos]=value[pos*2+1]+value[pos*2+2];
}

int sum_of_segment(int sleft,int sright,int left,int right,int pos)
{
    if (sright<left||sleft>right)
        return 0;
    if (left>=sleft&&right<=sright)
        return value[pos];
    int mid=(left+right)/2;
    return sum_of_segment(sleft,sright,left,mid,pos*2+1)
           +sum_of_segment(sleft,sright,mid+1,right,pos*2+2);
}

int main() {
    // 自定义测试数据
    vector<int> v = {1, 3, 5, 7, 9, 11}; // 原始数组
    int n = v.size();

    // 初始化线段树
    segment_tree(n, v);

    // 构建线段树
    buildtree(0, 0, n - 1);

    // 查询区间和示例
    int sleft = 1, sright = 3; // 查询区间 [1, 3]
    cout << "Sum of range [" << sleft << ", " << sright << "]: "
         << sum_of_segment(sleft, sright, 0, n - 1, 0) << endl;

    // 更新操作示例
    int index = 2; // 更新位置
    int new_value = 6; // 更新的新值
    cout << "Updating index " << index << " to value " << new_value << endl;
    update(index, new_value, 0, n - 1, 0);

    // 再次查询区间和，查看更新效果
    cout << "Sum of range [" << sleft << ", " << sright << "]: "
         << sum_of_segment(sleft, sright, 0, n - 1, 0) << endl;

    return 0;
}
// 64 位输出请用 printf("%lld")
```



# 网络

## HTTP协议
客户端发送的请求报文 第一行为请求行，包含了方法字段。
请求可以使用多种请求方法。eg：GET, POST 和 HEAD方法。
1.    GET	请求指定的页面信息，并返回实体主体。
2.    HEAD	类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头

3.    POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被 包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
### GET 和 POST 的区别，你知道哪些
1.	get是获取数据，post是修改数据
2.	get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而
post把数据放在HTTP的包体内（requrest body）
3.	get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。

4.	GET产生一个TCP数据包，浏览器会把http   header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。
5.	GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
6.	本质区别：GET是幂等的，而POST不是幂等的
> 这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意 味着对同一URL的多个请求应该返回同样的结果。
正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get  请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这   种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。
## TCP、UDP
**TCP的包头**
- 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN）， 之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。
- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。
- 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。
- 标志位（6bit）: 
    - URG：标志紧急指针是否有效。                                       
    - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
    - PSH：提示接收端立即从缓冲读走数据。                          
    - RST：表示要求对方重新建立连接（复位报文段）。          
    - SYN：表示请求建立一个连接（连接报文段）。                 
    - FIN：表示关闭连接（断开报文段）。
- 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解  决流控。
- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。
### 2MSL
为什么要等待2MSL？
MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。有以下两个原因：

第一点：保证TCP协议的全双工连接能够可靠关闭：
由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于CLOESD状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入CLOSED状态，而要保持TIME_WAIT，当再次收到FIN的收，能够保证对方收到ACK，最后正确关闭连接。
第二点：保证这次连接的重复数据段从网络中消失
如果Client端发送最后的ACK直接进入CLOSED状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。
## KCP
严格意义上讲KCP并不是一种网络传输协议，它是为UDP写的可靠传输算法，它是把TCP的主要可靠传输机制移植到了UDP身上，让UDP变的可靠了起来
- 在TCP协议中使用了接收确认和重传机制。使得每一个信息都能保证到达，所以是可靠的。
- 而UDP是尽力传送，没有应答和重传机制，UDP只是将信息发送出去，对方收不收到也不进行应答。所以UDP协议是不可靠的。
  

TCP的可靠机制是在传输层完成的，而UDP在传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。这就是KCP做法，也是其他UDP可靠算法的做法，
>说到TCP可靠机制，先说一说自动重传请求（Automatic Repeat-reQuest，ARQ），ARQ是属于OSI模型中数据链路层的错误纠正协议之一，为什么说这个呢？因为TCP传输层的主要可靠传输机制思想来自于ARQ。ARQ因现在链路的性能较好，目前在数据链路层很少采用。
总结成一句话就是TCP的可靠传输机制是在 传输层完成的，而可靠机制原理应用的是ARQ的工作原理。搞懂了ARQ，就搞懂了真谛，当然TCP除了ARQ机制外，还有一些其他机制，本文章先讲ARQ的可靠机制原理后再讲TCP其他机制。
## IP地址分类
[链接1](https://blog.csdn.net/m0_37732829/article/details/94717850)
[链接2](https://blog.csdn.net/qq_41207757/article/details/107839099)
## TCP UDP 头部结构
[TCP](https://blog.csdn.net/baidu_17611285/article/details/80171239)
[UDP](https://blog.csdn.net/weixin_43142797/article/details/105648071)
## 零拷贝技术
[简述](https://blog.csdn.net/huhigher/article/details/134908031)
## 一台机器最多撑多少个TCP连接
[介绍](https://zhuanlan.zhihu.com/p/290651392)#
## 网络通信中的阻塞和非阻塞I/O的区别
[详解](https://xiaolincoding.com/os/6_file_system/file_system.html#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E-i-o-vs-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5-i-o)
阻塞 I/O，当用户程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。
**注意，阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程**。
非阻塞 I/O，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。

# OS 

## 多线程： 

（1）**线程同步。**线程同步是指协调多个线程的执行顺序，以保证它们能够正确地共享数据 和资源。线程同步的主要目的是确保： 

1. 原子性：确保某个操作或某段代码在一个线程执行时不会被其他线程打断。
2. 可见性：确保一个线程对共享变量的修改能够被其他线程看到。 
3. 有序性：确保线程之间的操作顺序符合程序员的预期。 

实现线程同步的常见方法包括互斥锁（mutex）、条件变量、信号量、读写锁等。 

（2）线程间的**通信**方式。线程之间的通信是指多个线程之间交换信息或协调它们的行为的 过程。线程通信的常见方式包括：

1. 共享内存：多个线程可以访问同一块内存区域，通过读写这块内存来交换信息。 

2. 消息传递：线程之间通过发送和接收消息来进行通信。 

3. 使用同步原语：如条件变量、信号量等，这些同步原语不仅用于同步线程的执行， 也可以用于线程之间的通信。 

（3）**线程死锁**。线程死锁是指两个或更多个线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法向前推进。死锁会导致系统资源的浪费，甚至使系统崩溃。 

产生死锁的原因主要有： 

1. 互斥条件：一个资源每次只能被一个线程使用。 
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 
3. 不可剥夺条件：线程已获得的资源，在末使用完之前，不能强行剥夺。 
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 

解决死锁的方法包括避免死锁（通过预防策略或避免策略）和检测与解除死锁（通过检测算法和恢复策略）。 
总之，线程同步、线程之间的通信和线程死锁是并发编程中需要重点关注的三个方面。 正确地处理这些问题可以确保程序的正确性和性能。

## 多进程

（1）多线程概念：多进程是指同时运行多个独立的进程，每个进程都有自己独立的内存空 间和系统资源。

（2）实现与原理：

多进程的实现依赖于操作系统的进程管理机制。操作系统通过进程控制块（PCB）来管理进程的状态、优先级、资源分配等信息，以及进程间的通信和同步机制。 当一个进程被创建时，操作系统会为其分配资源，并将其状态置为就绪态，等待CPU 调度执行。进程执行完毕后或被阻塞时，操作系统会进行相应的处理。 多进程的原理还涉及进程间的通信和同步，确保多个进程能够按照一定的顺序执行，避免出现竞争条件和死锁等问题。常见的进程通信方式包括管道、消息队列、信号量、共享内存等。

（3）**调度与切换**：操作系统负责进程的调度和切换。常见的调度算法包括先来先服务、最短作业优先、时 间片轮转、多级反馈队列等。

（4）创建与销毁： 进程的创建和销毁也是多进程管理的一部分。Linux中用`fork`创建进程，Windows中用 `CreateProcess`创建进程。

## 用户级线程和内核级线程
1. 用户级线程（User-Level Threads, ULT）
    1. 线程管理：用户级线程的创建、管理和销毁都在用户空间进行，不需要内核的参与。这些线程通常由线程库（如POSIX线程库）管理。
    2. 上下文切换：由于上下文切换在用户空间完成，不涉及内核态的切换，因此速度快，开销小。
    3. 系统调用：用户级线程的操作无需系统调用，这使得线程操作更加高效，但在进行I/O操作时，整个进程会被阻塞。
    4. 多线程调度：用户级线程由用户级库调度，无法利用多核处理器的优势，因为内核只看到单个进程，而不识别其内部的多个线程。
2. 内核级线程（Kernel-Level Threads, KLT）
    1. 线程管理：内核级线程的创建、管理和销毁由操作系统内核负责，需要通过系统调用进行。
    2. 上下文切换：上下文切换需要从用户态切换到内核态，这使得切换速度较慢，开销较大。
    3. 系统调用：内核级线程的操作需要系统调用，尽管开销较大，但可以利用操作系统的各种功能，如进程调度和I/O操作。
    4. 多线程调度：内核级线程由操作系统调度，可以充分利用多核处理器的优势，因为内核能够识别和管理每个线程。
## 程序什么时候单线程效率高？
1) 任务不需要并行处理
如果任务本质上是顺序的，没有并行执行的需求或潜力，使用单线程可能更简单且高效。这类任务包括对数据进行线性处理，如读取文件然后处理数据，再写回文件。
2. 避免上下文切换的开销
多线程程序涉及线程之间的上下文切换，尤其是在单核处理器上运行时，这会带来显著的性能开销。单线程程序没有这种额外负担，因此在资源受限的环境中可能表现得更好。
2. 避免同步机制的开销
多线程程序需要同步机制（如互斥锁、信号量等）来管理对共享资源的访问，这不仅增加了编程的复杂性，还可能引入死锁和竞态条件等问题。这些同步操作本身就是一种开销，可能会降低程序的运行效率。单线程程序则无需考虑这些问题。
4. I/O密集型应用
在I/O密集型应用中，程序的性能瓶颈通常是磁盘I/O或网络I/O，而不是CPU。在这种情况下，使用多线程可能不会带来明显的性能提升，因为大部分时间都花在了等待I/O操作完成上。单线程模型在这种情况下简化了设计，且效率足够高。
5. 内存使用优化
多线程程序每个线程都可能需要自己的堆栈等资源，这在内存使用上可能不如单线程程序高效。在内存资源受限的环境中，单线程程序能更好地利用有限的内存资源。
6. 非共享资源的操作
如果程序中的任务完全独立，不需要共享任何资源，单线程执行可能更为直接和高效。这样可以避免多线程程序中资源锁定和同步的复杂性。
## 进程的创建需要系统分配什么资源？
1. 内存空间
    1. 代码段：存储程序的可执行代码。每个进程都会分配一个代码段，用于存放程序指令。
    2. 数据段：存储全局变量和静态变量。数据段在程序运行期间保持固定大小。
    3. 堆区：用于动态内存分配。在程序运行期间，可以通过malloc或new动态分配和释放内存。
    4. 栈区：用于存储局部变量和函数调用栈帧。每次函数调用都会在栈上分配新的栈帧。
2. 进程控制块 (PCB)
    1. 进程状态：表示进程当前的状态，如运行、就绪、等待等。
    2. 寄存器上下文：保存进程的CPU寄存器值，包括程序计数器、栈指针等，用于在上下文切换时恢复进程的执行状态。
    3. 调度信息：包含进程优先级、调度队列等信息，用于操作系统调度进程。
3. 文件描述符
每个进程都有一个文件描述符表，存储进程打开的文件及其对应的文件描述符。
4. 进程号 (PID)
每个进程都有一个唯一的进程号 (PID)，用于标识进程。
5. CPU时间片
操作系统为每个进程分配CPU时间片，用于进程调度和执行。
6. 系统资源和权限
包括网络连接、设备访问权限等。操作系统在创建进程时会为其分配必要的系统资源和权限。
## linux下的信号量
### 信号量的基本概念
- 信号量（Semaphore）：是一个整数计数器，用于协调多个线程或进程对共享资源的访问。
+ 信号量的值：
    -    大于0：表示可用资源的数量。
    - 等于0：表示资源不可用，进入阻塞状态。
    - 小于0：表示有线程/进程在等待资源。

信号量常用于实现互斥锁（mutex）和条件同步。
Linux 下信号量的类型：在Linux中，信号量有两种实现方式：
1. POSIX信号量（推荐用于线程间同步）
2. System V信号量（适用于进程间同步）
### POSIX 信号量
POSIX 信号量 API 函数
要使用POSIX信号量，必须包含头文件：`#include <semaphore.h>`
常用的POSIX信号量函数：
- sem_init()：初始化一个信号量（用于线程间的信号量）。
* sem_destroy()：销毁信号量。
* sem_wait()：对信号量进行P操作（减少1，如果为0则阻塞）。
* sem_post()：对信号量进行V操作（增加1）。
* sem_getvalue()：获取信号量的当前值。

POSIX 信号量示例：线程同步
```cpp
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

sem_t semaphore;  // 定义一个信号量

void* worker(void* arg) {
    sem_wait(&semaphore);  // P操作：获取信号量，如果为0则阻塞
    printf("Thread %ld is working...\n", (long)arg);
    sleep(2);  // 模拟工作时间
    printf("Thread %ld finished.\n", (long)arg);
    sem_post(&semaphore);  // V操作：释放信号量
    return NULL;
}

int main() {
    sem_init(&semaphore, 0, 2);  // 初始化信号量，初始值为2（可同时允许2个线程工作）

    pthread_t threads[5];
    for (long i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, worker, (void*)i);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);  // 等待所有线程结束
    }

    sem_destroy(&semaphore);  // 销毁信号量
    return 0;
}
```
说明：
- 使用sem_wait()进行P操作，如果信号量的值为0，线程会阻塞。
- 使用sem_post()进行V操作，增加信号量的值，唤醒阻塞线程。
- 在示例中，最多只能有2个线程同时工作，因为信号量初始值为2。
### System V 信号量
System V 信号量适用于进程间同步，它与POSIX信号量在API和实现上有一些不同。常用的函数包括：
* semget()：创建或获取一个信号量集。
* semctl()：控制信号量集（例如设置或获取信号量的值）。
* semop()：对信号量进行P/V操作。

System V 信号量示例：进程同步
```cpp
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>

void P(int semid) {
    struct sembuf p = {0, -1, 0};  // P操作：减少信号量值，如果为0则阻塞
    semop(semid, &p, 1);
}

void V(int semid) {
    struct sembuf v = {0, 1, 0};  // V操作：增加信号量值
    semop(semid, &v, 1);
}

int main() {
    key_t key = ftok("semfile", 65);  // 生成键值
    int semid = semget(key, 1, 0666 | IPC_CREAT);  // 创建信号量集
    semctl(semid, 0, SETVAL, 1);  // 初始化信号量值为1

    if (fork() == 0) {  // 子进程
        P(semid);  // 获取信号量
        printf("Child process is working...\n");
        sleep(2);
        printf("Child process finished.\n");
        V(semid);  // 释放信号量
    } else {  // 父进程
        P(semid);  // 获取信号量
        printf("Parent process is working...\n");
        sleep(2);
        printf("Parent process finished.\n");
        V(semid);  // 释放信号量
        wait(NULL);  // 等待子进程结束
        semctl(semid, 0, IPC_RMID);  // 删除信号量
    }

    return 0;
}
```
说明：
- 使用semop()对信号量进行P/V操作。
- 父进程和子进程使用同一个信号量来同步，确保不会同时访问共享资源。

在 System V 信号量 中，`struct sembuf `结构体用于描述单个信号量的操作。这是执行 `P`（等待）操作和 `V`（释放）操作时的关键结构，配合 `semop()` 函数一起使用。在 `<sys/sem.h>` 头文件中，`struct sembuf` 结构体定义如下：
```cpp
struct sembuf {
    unsigned short sem_num;  // 信号量编号（在信号量集合中的索引）
    short sem_op;            // 信号量操作（P操作为-1，V操作为+1）
    short sem_flg;           // 操作标志（可设置为 IPC_NOWAIT 或 SEM_UNDO）
};
```
字段解释
1. `sem_num`
    - 含义：表示对信号量集中第几个信号量进行操作。
    - 信号量集（semaphore set）是由多个信号量组成的集合，通过 `semget()` 创建，`sem_num` 指定在该集合中的索引位置。
    - 索引从 0 开始。例如，如果一个信号量集中有3个信号量，要操作第2个信号量，就设置 `sem_num = 1`。
2. `sem_op`
    - 含义：指定信号量的操作。
    - 常见值：
        - -1：P操作（即获取信号量，减少计数，如果信号量值为0，则阻塞）。
        - +1：V操作（即释放信号量，增加计数，唤醒等待的进程/线程）。
        - 0：表示等待信号量的值变为 0（常用于同步）。
3. `sem_flg`
    - 含义：指定操作的标志，常用于控制操作的行为。
    - 常见标志：
        - `IPC_NOWAIT`：如果操作不能立即完成，则不会阻塞当前进程，而是直接返回错误。
        - `SEM_UNDO`：使操作具备“撤销”能力，如果进程在获取信号量后意外终止，系统会自动释放信号量。
        `semop()` 函数是执行信号量操作的函数：
```cpp
int semop(int semid, struct sembuf *sops, size_t nsops);
```
- `semid`：信号量集的ID，由 semget() 返回。
- `sops`：指向 struct sembuf 数组的指针，表示要执行的操作。
- `nsops`：要执行的信号量操作的数量。

示例 `P` `V`操作
```c
struct sembuf p_op = {0, -1, SEM_UNDO};  // P操作：获取信号量，支持自动撤销
struct sembuf v_op = {0, +1, SEM_UNDO};  // V操作：释放信号量，支持自动撤销

semop(semid, &p_op, 1);  // 获取信号量
printf("Critical section.\n");
semop(semid, &v_op, 1);  // 释放信号量
```
在这个例子中，我们会创建 两个信号量，分别代表 资源A 和 资源B，每种资源各有 3个单位。
- 子进程尝试获取1个资源A和1个资源B。
- 父进程在子进程释放资源后增加它们的数量。

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>

#define SEM_A 0  // 资源A的信号量索引
#define SEM_B 1  // 资源B的信号量索引

// P操作：减少指定信号量的资源
void P(int semid, int semnum, int val) {
    struct sembuf p_op = {semnum, -val, 0};  // 减少 val 个资源
    if (semop(semid, &p_op, 1) == -1) {
        perror("P operation failed");
        exit(1);
    }
}

// V操作：增加指定信号量的资源
void V(int semid, int semnum, int val) {
    struct sembuf v_op = {semnum, +val, 0};  // 增加 val 个资源
    if (semop(semid, &v_op, 1) == -1) {
        perror("V operation failed");
        exit(1);
    }
}

int main() {
    key_t key = ftok("semfile", 65);  // 创建唯一键值
    // 创建2个信号量，每个初始化为3（表示各有3个资源）
    int semid = semget(key, 2, 0666 | IPC_CREAT);
    if (semid == -1) {
        perror("semget failed");
        exit(1);
    }

    semctl(semid, SEM_A, SETVAL, 3);  // 初始化信号量A为3
    semctl(semid, SEM_B, SETVAL, 3);  // 初始化信号量B为3

    if (fork() == 0) {  // 子进程
        printf("Child trying to acquire 1 resource A and 1 resource B...\n");
        P(semid, SEM_A, 1);  // 获取1个资源A
        P(semid, SEM_B, 1);  // 获取1个资源B
        printf("Child acquired 1 resource A and 1 resource B.\n");

        sleep(2);  // 模拟工作

        printf("Child releasing 1 resource A and 1 resource B...\n");
        V(semid, SEM_A, 1);  // 释放1个资源A
        V(semid, SEM_B, 1);  // 释放1个资源B
        exit(0);
    } else {  // 父进程
        sleep(1);  // 等待子进程获取资源

        printf("Parent adding 2 resources to A and B...\n");
        V(semid, SEM_A, 2);  // 增加2个资源A
        V(semid, SEM_B, 2);  // 增加2个资源B

        wait(NULL);  // 等待子进程结束

        printf("Final resources: A=%d, B=%d\n", 
               semctl(semid, SEM_A, GETVAL),
               semctl(semid, SEM_B, GETVAL));

        semctl(semid, 0, IPC_RMID);  // 删除信号量集
    }

    return 0;
}
```
示例说明
1. 初始化两个信号量（A和B），初始值各为3。
2. 子进程：
    - 获取1个A和1个B资源。
    - 模拟工作2秒后释放这些资源。
3. 父进程：
    - 等待1秒后增加2个A和2个B资源。
    - 打印最终资源数并删除信号量集。
### POSIX 与 System V 信号量的区别
|特性|	POSIX 信号量	|System V 信号量|
|:--:|:--:|:--:|
|用途|	线程或进程间同步|	主要用于进程间同步|
|API|	简单易用|	较复杂|
|信号量类型|	二元信号量和计数信号量|	计数信号量|
|性能|	更轻量，适用于多线程环境|	较重，适用于进程间通信|
|资源释放|	进程结束后自动释放|	需要手动删除|
总结
- POSIX信号量适用于线程之间的同步操作，因为它更轻量、简单。
- System V信号量适用于进程之间的同步操作，适合需要复杂同步控制的场景。
- 信号量是解决竞争条件和同步问题的关键工具，常用于实现互斥和同步机制。
## 消息队列
允许进程之间以**消息**的形式传递数据。每个消息队列都有一个 唯一的标识符，进程可以通过**发送和接收**消息在它们之间进行数据交换。
### 消息队列的基本概念
1. 消息队列是一块内核维护的内存区域，可以存放消息。
2. 每条消息通常包含：
    - 一个 类型标识符（long 型整数）。
    - 一段 数据（通常为字符串或结构体）。
3. 进程通过系统调用将消息发送到队列中，或从队列中读取消息。
### 关键的系统调用
- `msgget()`：创建或获取一个消息队列。
- `msgsnd()`：向消息队列发送消息。
- `msgrcv()`：从消息队列接收消息。
- `msgctl()`：控制消息队列，如删除队列。

结构体：`msgbuf`
消息队列的消息必须遵循下面的结构体格式
```cpp
struct msgbuf {
    long mtype;       // 消息类型（必须为正整数）
    char mtext[100];  // 消息内容
};
```
- `mtype`：消息类型，接收消息时可以根据类型筛选。
- `mtext`：消息正文，存储要传递的数据。

示例：
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>

#define MSG_SIZE 100

// 消息结构体
struct msgbuf {
    long mtype;            // 消息类型
    char mtext[MSG_SIZE];  // 消息正文
};

int main() {
    key_t key = ftok("msgqueue", 65);  // 生成唯一键
    int msgid = msgget(key, 0666 | IPC_CREAT);  // 创建消息队列

    if (fork() == 0) {  // 子进程：发送消息
        struct msgbuf msg;
        msg.mtype = 1;  // 类型为1的消息
        strcpy(msg.mtext, "Hello from child process");

        msgsnd(msgid, &msg, sizeof(msg.mtext), 0);  // 发送消息
        printf("Child: Sent message to parent.\n");
        exit(0);
    } else {  // 父进程：接收消息
        struct msgbuf msg;
        msgrcv(msgid, &msg, sizeof(msg.mtext), 1, 0);  // 接收类型为1的消息

        printf("Parent: Received message: %s\n", msg.mtext);

        // 删除消息队列
        msgctl(msgid, IPC_RMID, NULL);
        printf("Parent: Message queue deleted.\n");
    }

    return 0;
}
```
示例解析
1. 创建消息队列：
    - 使用 `ftok()` 生成唯一键值，并通过 `msgget()` 创建队列。
2. 子进程发送消息：
    - 构建一条类型为1的消息并发送到队列中。
3. 父进程接收消息：
    - 使用 `msgrcv()` 接收类型为1的消息并打印。
4. 删除消息队列：
    - 父进程使用 `msgctl()` 删除队列。

关键点总结
1. 消息类型过滤：msgrcv() 可以根据类型接收特定消息，支持灵活的通信机制。
2. 内核队列管理：消息队列由内核维护，必须在不再使用时删除队列，以避免内存泄漏。
3. 进程间解耦：发送方和接收方不需要直接建立连接，减少耦合性。

## 调度算法

### **最早截止优先调度算法（Earliest Deadline First, EDF）**

它根据任务的截止时间进行优先级排序，优先处理截止时间最早的任务。

1. **保证任务的可调度性（Schedulability）**

- 在单处理器环境下，如果系统的**总CPU利用率**
  $$
  𝑈
  =
  ∑
  𝐶
  𝑖
  /
  𝑇
  𝑖
  ≤
  1
  $$
  （其中 CiC_iCi 是任务的执行时间，TiT_iTi 是任务的周期时间），则EDF算法可以**确保所有任务在其截止时间之前完成**。

- 如果利用率超过1，则EDF不能保证所有任务都在截止时间内完成。

2. **最优的单处理器调度算法**

- EDF是单处理器系统中最优的动态优先级调度算法。当系统可调度时，EDF能在**利用率最大化的情况下**调度任务，即不会有其他算法能够在更高的负载下保持任务的准时完成。

3. **及时响应任务截止时间**

- EDF算法动态调整任务的优先级，使得**最早截止的任务**始终获得最高优先级。这确保了系统能够及时响应靠近截止的任务，从而适合用于具有严格截止时间的实时系统。

4. **容错性和灵活性**

- 在某些负载突然增加的情况下，EDF可以较灵活地调整优先级，先处理最紧急的任务，从而使系统在高负载下尽可能满足更多的截止要求（虽然不能完全保证所有任务的可调度性）。

在单处理器实时系统中，EDF算法**保证所有任务在截止时间前完成**，前提是任务的总利用率不超过1，且它被认为是单处理器调度中**最优的动态算法**。

# QT
## JSON在Qt中
首先，一个JSON的示例：
```json
 {
     "FirstName": "John",
     "LastName": "Doe",
     "Age": 43,
     "Address": {
         "Street": "Downing Street 10",
         "City": "London",
         "Country": "Great Britain"
     },
     "Phone numbers": [
         "+44 1234567",
         "+44 2345678"
     ]
 }
```
JSON是一种存储结构化数据的格式。它有6种基本数据类型:
```dotnetcli
bool double string array object null
```
JSON的文本表示将数组括在方括号中([…]])和花括号({…})。数组和对象中的条目用逗号分隔。对象中键和值之间的分隔符是冒号（:）。**一般可以理解为[]包括的是数组即QJsonArray，{}包括的是对象即QJsonObject**
```cpp
QJsonArray                    //封装JSON数组
QJsonDocument                 //读取和写入JSON文档的方法
QJsonObject                   //封装JSON对象
QJsonObject::const_iterator   //const_iterator类为QJsonObject提供了一个stl风格的常量迭代器
QJsonObject::iterator         //提供了一个stl风格的非常量迭代器
QJsonParseError               //用于报告JSON解析过程中的错误
QJsonValue                    //将值封装在JSON中
```
### 演示如何保存和加载一个简单的游戏到JSON和二进制格式

```cpp
 class Character
 {
     Q_GADGET;

 public:
     enum ClassType {
         Warrior, Mage, Archer
     };
     Q_ENUM(ClassType)

     Character();
     Character(const QString &name, int level, ClassType classType);

     QString name() const;
     void setName(const QString &name);

     int level() const;
     void setLevel(int level);

     ClassType classType() const;
     void setClassType(ClassType classType);

     void read(const QJsonObject &json);
     void write(QJsonObject &json) const;

     void print(int indentation = 0) const;
 private://三种属性，即三种键值 key。
     QString mName;
     int mLevel;
     ClassType mClassType;
 };

 void Character::read(const QJsonObject &json)
 {
     if (json.contains("name") && json["name"].isString())
         mName = json["name"].toString();

     if (json.contains("level") && json["level"].isDouble())
         mLevel = json["level"].toInt();

     if (json.contains("classType") && json["classType"].isDouble())
         mClassType = ClassType(json["classType"].toInt());
 }

 void Character::write(QJsonObject &json) const
 {
     json["name"] = mName;
     json["level"] = mLevel;
     json["classType"] = mClassType;
 }
/*
在read()函数中，我们从QJsonObject参数中为Character的成员赋值。
您可以使用QJsonObject::operator[]()或QJsonObject::value()来访问JSON对象中的值;
两者都是const函数，如果键无效则返回QJsonValue::Undefined。
在尝试使用QJsonObject::contains()读取键之前，我们检查键是否有效。

将Character对象中的值赋给JSON对象。
与访问值一样，有两种方法可以在QJsonObject上设置值:QJsonObject::operator[]()和QJsonObject::insert()。
两者都将覆盖给定键处的任何现有值。
*/
```

```cpp
//关卡类
 class Level
 {
 public:
     Level() = default;
     Level(const QString &name);

     QString name() const;

     QVector<Character> npcs() const;
     void setNpcs(const QVector<Character> &npcs);

     void read(const QJsonObject &json);
     void write(QJsonObject &json) const;

     void print(int indentation = 0) const;
 private://每个关卡都有几个npc，所以我们保留了角色对象的QVector。
     QString mName;
     QVector<Character> mNpcs;
 };

 void Level::read(const QJsonObject &json)
 {
     if (json.contains("name") && json["name"].isString())
         mName = json["name"].toString();

     if (json.contains("npcs") && json["npcs"].isArray()) {
         QJsonArray npcArray = json["npcs"].toArray();
         mNpcs.clear();
         mNpcs.reserve(npcArray.size());
         for (int npcIndex = 0; npcIndex < npcArray.size(); ++npcIndex) {
             QJsonObject npcObject = npcArray[npcIndex].toObject();
             Character npc;
             npc.read(npcObject);
             mNpcs.append(npc);
         }
     }
 }

 void Level::write(QJsonObject &json) const
 {
     json["name"] = mName;
     QJsonArray npcArray;
     for (const Character &npc : mNpcs) { //从vector中每一项作为一个QJsonObject，然后在写入NPC的QJsonArray中
         QJsonObject npcObject;
         npc.write(npcObject);
         npcArray.append(npcObject);
     }
     json["npcs"] = npcArray;
 }
/*容器可以使用QJsonArray对JSON进行读写。
在我们的例子中，我们从键“npc”关联的值构造一个QJsonArray。
然后，对于数组中的每个QJsonValue元素，我们调用toObject()来获取字符的JSON对象。
字符对象可以读取它们的JSON并添加到我们的NPC数组中。*/
```
### 一个复杂JSON对象的例子
```json
{
    "address": null,
    "age": 26,
    "color": [
        "black",
        "white"
    ],
    "interest": {
        "badminton": "yumaoqiu",
        "basketball": "lanqiu"
    },
    "languages": {
        "serialOne": {
            "grade": 10,
            "language": "hanyu"
        },
        "serialTwo": {
            "grade": 6,
            "language": "yingyu"
        }
    },
    "like": [
        {
            "game": "sanguosha",
            "price": 58.5
        },
        {
            "game": "haidaoqibing",
            "price": 66.65
        }
    ],
    "name": "laowang",
    "vip": true
}
```
由于中文有问题，替换了一些。
#### 封装json
```cpp
    //封装JSON的过程
    // 定义 { } 对象
    QJsonObject interestObj;
    interestObj.insert("basketball","lanqiu");
    interestObj.insert("badminton","yumaoqiu");

    // 定义 [ ] 对象
    QJsonArray colorArray;
    colorArray.append("black"); // 往数组中添加元素
    colorArray.append("white");


    QJsonObject likeObject1;
    likeObject1.insert("game", "sanguosha");
    likeObject1.insert("price", 58.5);
    QJsonObject likeObject2;
    likeObject2.insert("game", "haidaoqibing");
    likeObject2.insert("price", 66.65);
    QJsonArray likeArray;
    likeArray.append(likeObject1);
    likeArray.append(likeObject2);

    QJsonObject language1;
    language1.insert("language", "hanyu");
    language1.insert("grade", 10);
    QJsonObject language2;
    language2.insert("language", "yingyu");
    language2.insert("grade", 6);
    QJsonObject languages;
    languages.insert("serialOne", language1);
    languages.insert("serialTwo", language2);

    QJsonArray ColorAr;
    QJsonArray ColorAr1;
    ColorAr1.append("black");
    ColorAr1.append("white");
    QJsonArray ColorAr2;
    ColorAr2.append("red");
    ColorAr2.append("greed");
    ColorAr.append(ColorAr1);
    ColorAr.append(ColorAr2);

    // 定义根节点	也即是最外层 { }
    QJsonObject rootObject;
    // 插入元素
    rootObject.insert("name", "laowang");
    rootObject.insert("age", 26);
    rootObject.insert("interest", interestObj);
    rootObject.insert("color", colorArray);
    rootObject.insert("like", likeArray);
    rootObject.insert("languages", languages);
    rootObject.insert("vip", true);
    rootObject.insert("address", QJsonValue::Null);

    //实例化QJsonDocument对象
    // 将json对象里的数据转换为字符串
    QJsonDocument doc;
    // 将object设置为本文档的主要对象
    doc.setObject(rootObject);
    //    Json字符串保存到json文件里
    QFile file("./js.json");
    if(!file.open(QIODevice::WriteOnly|QIODevice::Truncate))
    {
        qDebug() << "can't open error!";
        return 0;
    }
    QTextStream stream(&file);
    stream.setCodec("UTF-8");		// 设置写入编码是UTF8
    // 写入文件
    stream << doc.toJson();
    file.close();
```
#### 解析json
在使用JSON对象或者JSON数组对象得到对应的value之后，该value值并不是最终的数据类型，而是一个QJsonValue类型的属性，我们必须通过该对象判断该类型的实际类型，然后在将其转换为对应的数据类型。
```cpp
bool isArray() const	//是否为json数组
bool isBool() const	    //是否为布尔类型
bool isDouble() const	//是否为浮点类型
bool isNull() const	    //是否为空
bool isObject() const	//是否为json对象
bool isString() const	//是否为字符串类型
```

```cpp
//    打开文件，读取全部内容
    QFile file("./js.json");
    if(!file.open(QFile::ReadOnly|QFile::Text))
    {
        qDebug() << "can't open error!";
        return -1;
    }

    // 读取文件的全部内容
    QTextStream stream(&file);
    stream.setCodec("UTF-8");		// 设置读取编码是UTF8
    QString str = stream.readAll();
    file.close();

//    将字符串解析成QJsonDocument对象
    // QJsonParseError类用于在JSON解析期间报告错误。
    QJsonParseError jsonError;
    // 将json解析为UTF-8编码的json文档，并从中创建一个QJsonDocument。
    // 如果解析成功，返回QJsonDocument对象，否则返回null
    QJsonDocument doc=QJsonDocument::fromJson(str.toUtf8(),&jsonError);
    //判断是否解析失败
    if(jsonError.error!=QJsonParseError::NoError && !doc.isNull())
    {
        qDebug() << "Json_is_error" << jsonError.error;
        return -2;
    }
    //获取根{}
    QJsonObject rootObj=doc.object();
    //获取键值
    QJsonValue namevalue=rootObj.value("name");
    qDebug() << "name = " << namevalue.toString();
    QJsonValue argvalue=rootObj.value("age");
    qDebug() << "age = " << argvalue.toInt();
    // 解析 bool类型
    QJsonValue vipValue = rootObj.value("vip");
    qDebug() << "vip = " << vipValue.toBool();
    // 解析 null类型
    QJsonValue addressValue = rootObj.value("address");
    if (addressValue.type() == QJsonValue::Null) {
        qDebug() << "address = " << "null";
    }

    //解析对象{}
    QJsonValue interestValue=rootObj.value("interest");
    //判断是否object
    if(interestValue.type()==QJsonValue::Object)
    {
        //转化为QjsonObject类型
        QJsonObject interestObj=interestValue.toObject();
        QJsonValue basketballvalue=interestObj.value("basketball");
        qDebug() << "basketball = " << basketballvalue.toString();
        QJsonValue badmintonValue = interestObj.value("badminton");
        qDebug() << "badminton = " << badmintonValue.toString();
    }

    //解析数组
    QJsonValue colorValue = rootObj.value("color");
    // 判断是否是Array类型
    if (colorValue.type() == QJsonValue::Array) {
        // 转换为QJsonArray类型
        QJsonArray colorArray = colorValue.toArray();
        for(int i=0;i<colorArray.size();i++)
        {
            QJsonValue color=colorArray.at(i);
            qDebug() << "color = " << color.toString();
        }
    }

    //解析数组中的对象 [ { } ]
    //根据键获得值
    QJsonValue likeValue=rootObj.value("like");
    //判断类型是否数组
    if(likeValue.type()==QJsonValue::Array)
    {
        //转换成数组
        QJsonArray likeArray=likeValue.toArray();
        for(int i=0;i<likeArray.count();i++)
        {
            // 获取数组的第一个元素，类型是QJsonValue
            QJsonValue likeValueChild = likeArray.at(i);
            // 判断是不是对象类型
            if(likeValueChild.type()==QJsonValue::Object)
            {
                // 转换成对象类型
                QJsonObject likeObj=likeValueChild.toObject();
                // 最后通过value函数就可以获取到值了，解析成功！
                QJsonValue gameLikeValue = likeObj.value("game");
                qDebug() << "game = " << gameLikeValue.toString();
                QJsonValue priceLikeValue = likeObj.value("price");
                qDebug() << "price = " << priceLikeValue.toDouble();
            }
        }
    }

    //解析 对象 中 对象 { { } }
    // 根据建获取值
    QJsonValue languagesValue = rootObj.value("languages");
    // 判断是不是对象类型
    if (languagesValue.type() == QJsonValue::Object) {
        // 转换成对象类型
        QJsonObject languagesObj = languagesValue.toObject();
        // 根据建获取值
        QJsonValue serialOneValue = languagesObj.value("serialOne");
        // 判断是不是对象类型
        if (serialOneValue.type() == QJsonValue::Object) {
            // 转换成对象类型
            QJsonObject serialOneObj = serialOneValue.toObject();
            // 根据建获取值
            QJsonValue languageValue = serialOneObj.value("language");
            // 最后转换成对应类型就解析出来了！
            qDebug() << "language = " << languageValue.toString();
            QJsonValue gradeValue = serialOneObj.value("grade");
            qDebug() << "grade = " << gradeValue.toInt();
        }

        QJsonValue serialTwoValue = languagesObj.value("serialTwo");
        if (serialTwoValue.type() == QJsonValue::Object) {
            QJsonObject serialTwoObj = serialTwoValue.toObject();

            QJsonValue languageValue = serialTwoObj.value("language");
            qDebug() << "language = " << languageValue.toString();
            QJsonValue gradeValue = serialTwoObj.value("grade");
            qDebug() << "grade = " << gradeValue.toInt();
        }
    }
    
    //解析数组中数组[[][]]
    // 根键获取值
    QJsonValue colorValue = rootObject.value("color");
    // 判断类型是否是数组类型
    if (colorValue.type() == QJsonValue::Array) {
        // 转换成数组类型
        QJsonArray colorArray = colorValue.toArray();
        // 遍历数组
        for (int i = 0; i < colorArray.count(); i++) {
            // 获取数组的第一个元素，类型是QJsonValue 
		QJsonValue colorValueChild = colorArray.at(i);
            // 判断是不是数组类型
            if (colorValueChild.type() == QJsonValue::Array) {
                // 转换成数组类型
                QJsonArray colorArr = colorValueChild.toArray();
                
                for (int i = 0; i < colorArr.size(); i++) {
                    QJsonValue color = colorArr.at(i);
                    qDebug() << "color = " << color.toString();
                }
                
            }
        }
    }
```
#### 修改json
修改的过程就是：将数据从文件中读取出来，解析成QJsonDocument对象后，在获取跟对象{ }，通过跟对象在获取其他的对象{}或者数组[]，修改后，再赋值给跟对象{}，达到替换效果，也就是修改了，最后再写入文件即可！
```cpp
// 获取根 { }
QJsonObject rootObj = doc.object();
// 修改name属性
rootObj["name"] = "老李";
rootObj["vip"] = false;

//修改数组中的元素
QJsonValue colorValue = rootObj.value("color");
if (colorValue.type() == QJsonValue::Array) {
	QJsonArray colorArray = colorValue.toArray();
	// 修改数组中的值
	colorArray.replace(0, "blue");
	colorArray.replace(1, "green");
	// 赋值覆盖原有数组属性
	rootObj["color"] = colorArray;
}

//修改对象值
QJsonValue interestValue = rootObj.value("interest");
if (interestValue.type() == QJsonValue::Object) {
	QJsonObject interestObject = interestValue.toObject();
	interestObject["badminton"] = "乒乓球";
	interestObject["basketball"] = "足球";
	rootObj["interest"] = interestObject;
}

//修改{{}}
QJsonValue languagesValue = rootObj.value("languages");
if (languagesValue.type() == QJsonValue::Object) {
	QJsonObject languagesObj = languagesValue.toObject();

	// 找到内部第一个 { }
	QJsonValue serialOneValue = languagesObj.value("serialOne");
	if (serialOneValue.type() == QJsonValue::Object) {
		QJsonObject serialOneObj = serialOneValue.toObject();

		serialOneObj["grade"] = "20";

		languagesObj["serialOne"] = serialOneObj;
	}

	// 找到内部第二个 { }
	QJsonValue serialTwoValue = languagesObj.value("serialTwo");
	if (serialTwoValue.type() == QJsonValue::Object) {
		QJsonObject serialTwoObj = serialTwoValue.toObject();

		serialTwoObj["grade"] = "10";
		serialTwoObj["language"] = "粤语";

		languagesObj["serialTwo"] = serialTwoObj;
	}

	rootObj["languages"] = languagesObj;
}

//修改[{}]
QJsonValue likeValue = rootObj.value("like");
if (likeValue.type() == QJsonValue::Array) {
	QJsonArray likeArray = likeValue.toArray();

	// 根据索引获得对应{ }
	QJsonObject obj1 = likeArray[0].toObject();
	obj1["game"] = "欢乐斗地主";
	obj1["price"] = 88.8;
	QJsonObject obj2 = likeArray[1].toObject();
	obj2["game"] = "欢乐斗牛";
	obj2["price"] = 77.7;

	// 替换覆盖
	likeArray.replace(0, obj1);
	likeArray.replace(1, obj2);

	rootObj["like"] = likeArray;
}

```
```cpp
/*写入文件*/
// 将object设置为本文档的主要对象
doc.setObject(rootObj);

// 重写打开文件，覆盖原有文件，达到删除文件全部内容的效果
QFile writeFile("../Json/js.json");
if (!writeFile.open(QFile::WriteOnly | QFile::Truncate)) {
	qDebug() << "can't open error!";
	return;
}

// 将修改后的内容写入文件
QTextStream wirteStream(&writeFile);
wirteStream.setCodec("UTF-8");		// 设置读取编码是UTF8
wirteStream << doc.toJson();		// 写入文件
writeFile.close();					// 关闭文件
```
#### 删除json
删除属性
```cpp
// 删除age
rootObj.remove("age");
```
删除数组[]中的元素
```cpp
QJsonValue colorValue = rootObj.value("color");
if (colorValue.type() == QJsonValue::Array) {
	QJsonArray colorArray = colorValue.toArray();

	// 删除数组中索引为1的值
	colorArray.removeAt(1);

	// 赋值覆盖原有数组属性
	rootObj["color"] = colorArray;
}
```
删除 { } 中的值
```cpp
QJsonValue interestValue=rootObj.value("intrerst");
if(interestValue.type() == QJsonValue::Object)
{
    QJsonObject interestObject = interestValue.toObject();
    // 删除键为basketball的属性元素
	interestObject.remove("basketball");
    rootObj["interest"]=interestObject;
}
```
删除 { { } } 中的值
```cpp
QJsonValue languagesValue = rootObj.value("languages");
if (languagesValue.type() == QJsonValue::Object) {
	QJsonObject languagesObj = languagesValue.toObject();

	// 删除键为serialTwo的对象 { }
	languagesObj.remove("serialTwo");

	rootObj["languages"] = languagesObj;
}
```
删除 [ ] 中的 { }
```cpp
QJsonValue likeValue = rootObj.value("like");
if (likeValue.type() == QJsonValue::Array) {
	QJsonArray likeArray = likeValue.toArray();

	// 删除索引为1数组中的值
	likeArray.removeAt(1);

	rootObj["like"] = likeArray;
}
```
#### [另一个简单的示例](https://blog.csdn.net/rong11417/article/details/104252927)

## qt 定时器

### `start()` -`QTimer`类的成员函数

​        `start()`是 `QTimer 类`的成员函数，用于启动一个基于 `QTimer `对象的定时器。`QTimer` 是 Qt 中常用的定时器类，它会在设定的时间间隔后发出 `timeout() `信号。

用法

```c++
QTimer timer;
timer.start(1000);  // 每隔 1000 毫秒触发一次 timeout() 信号

QTimer timer;
QObject::connect(&timer,SIGNAL(timeout(), this, SLOT(on_m_clock_timeout());
timer.start(1000);  // 每隔 1000 毫秒调用一次 onTimeout()
```

       1. 参数：start(int msec)，其中 msec 是时间间隔（以毫秒为单位）。
       2. 触发信号：当时间间隔结束时，QTimer 会发出 timeout() 信号，你可以将这个信号连接到一个槽函数来处理。
       3. 连接信号与槽：通过 connect()，你可以将 SIGNAL（timeout()）信号连接到一个槽函数，这样每次定时器触发时，槽函数就会被调用。
       4. 自动处理：QTimer 自动管理信号与槽，因此非常适合需要定期执行某些任务的场景。

### `startTimer()`-`QObject`类的成员函数

startTimer() 是 QObject 类的成员函数，用于启动一个低级别的定时器。它返回一个定时器 ID，之后可以通过 killTimer() 来停止该定时器。

```c++
int timerId = startTimer(1000);  // 每隔 1000 毫秒触发一次定时器事件
```

1. 参数：startTimer(int msec)，其中 msec 是时间间隔（以毫秒为单位）。
2. 返回值：startTimer() 返回一个定时器 ID，你可以用这个 ID 来管理和停止定时器。

特点：

1. **不依赖信号与槽**：startTimer() 不使用信号与槽，而是通过事件处理机制触发 timerEvent()，需要在派生类中重写 timerEvent() 函数来处理定时器事件。
2. **低级别定时器**：startTimer() 是更低级别的定时器实现，适用于对性能要求较高或不需要复杂信号与槽机制的场景。
3. **手动停止**：你可以使用 killTimer(timerId) 来停止通过 startTimer() 启动的定时器。

### 对比

|       特性        |              `start()`(`QTimer`)               |                 `startTimer()`(`QObject`)                 |
| :---------------: | :--------------------------------------------: | :-------------------------------------------------------: |
|        类         |                     QTimer                     |                          QObject                          |
|     触发机制      |               通过timeout()信号                |               调用timerEvent()事件处理函数                |
|     使用场景      |         GUI 应用中，定期触发信号的场景         |      低级别定时器，适合对事件和性能有特殊需求的场景       |
|    停止定时器     |                     stop()                     |                    killTimer(timerId)                     |
|   依赖事件循环    |             是（基于信号与槽机制）             |                  是（通过事件机制处理）                   |
| 需要重写事件处理  |                       否                       |                 是，需要重写 timerEvent()                 |
| 是否返回定时器 ID |                       否                       |                     是，返回定时器 ID                     |
|     适合应用      | 适合需要信号与槽的定时器事件（如更新UI、动画） | 适合更细粒度控制和性能要求的场景（如后台处理、非GUI应用） |

### 总结

1. start() (QTimer)：适用于典型的定时任务，利用信号与槽机制进行处理。它适合在 GUI 应用中使用，能够方便地每隔一段时间执行某个任务，并且可以轻松管理和停止定时器。
2. startTimer() (QObject)：适用于需要更低级别定时器控制的场景，必须手动处理定时器事件（timerEvent()），并手动停止定时器（killTimer()）。适合需要更高性能或更细粒度控制的任务。

## QT网络模块

一、高层网络协议类简介

- Qt网络模块提供了一些类实现OSI 7层网络模型中高层的网络协议，如HTTP、FTP、SNMP等
- 这些类主要为：
  - QNetworkRequest类：通过一个URL地址发起网络协议请求，也保存网络请求的信息，目前支持HTTP、FTP和局部文件URLs的下载或上传
  - NetworkAccessManager类：用于协调网络操作。在QNetworkRequest发起一个网络请求后，NetworkAccessManager负责发送网络请求，创建网络响应
  - QNetworkReply类：表示网络请求的相应。由NetworkAccessManager在发送一个网络请求后创建一个网络响应。QNetworkReply提供finished()、readyRead()、downloadProgress()可以监测网络响应的执行情况，执行相应的操作
    QNetworkReply是QIODevice的子类，所以QNetworkReply支持流读写功能，也支持异步或同步工作
- 想要使用那个类就添加相应的头文件，头文件名与类型相同

## QT中的拖放事件

拖放一个文件进入窗口将触发拖放事件，每一个`QWidget`对象都能处理拖放事件

拖放事件的处理函数：

- `void dragEnterEvent(QDragEnterEvent* e);` 拖放进入事件
- `void dropEvent(QDropEvent* e);` 拖放放下事件

### 拖放事件中的`QmimeData`

`QmimeData`是 Qt 中的多媒体数据类

拖放事件通过` QmimeData` 对象传递数据

QmimeData 支持多种不同类型的多媒体数据

常用 MIME 类型数据处理函数

|   测试函数   |  获取函数   |     设置函数     |      MIME类型      |
| :----------: | :---------: | :--------------: | :----------------: |
| `hasText()`  |   `text`    |   `setText()`    |     text/plain     |
| `hasHtml()`  |   `html`    |   `setHtml()`    |     text/html      |
| `hasUrls()`  |   `urls`    |   `setUrls()`    |   text/url-list    |
| `hasImage()` | `imageData` | `setImageData()` |      image/*       |
| `hasColor()` | `colorData` | `setColorData()` | aplication/x-color |

### 自定义拖放事件的步骤

1. 对接收拖放事件的对象调用 `setAcceptDrops` 成员函数
2. 重写 `dragEnterEvent` 函数并判断 MIME 类型
   - 期望数据：`e->acceptProposedAction()；` **接受并执行由用户提出的建议或请求**
   - 其他数据：`e->ignore();`

3. 重写 `dropEvent` 函数并判断 MIME 类型
   - 期望数据：从事件对象中获取 MIME 对象并处理
   - 其他数据：`e->ignore();`

示例：

```c++
class Widget : public QWidget
{
    Q_OBJECT
 
public:
    Widget(QWidget* parent = nullptr);
    void dragEnterEvent(QDragEnterEvent* event);
    void dropEvent(QDropEvent* event);
    ~Widget();
};

Widget::Widget(QWidget* parent)
    : QWidget(parent)
{
    setAcceptDrops(true);
}
 
void Widget::dragEnterEvent(QDragEnterEvent* event)
{
    if(event->mimeData()->hasUrls())
    {
        event->acceptProposedAction();
    }
    else
    {
        event->ignore();
    }
}
 
void Widget::dropEvent(QDropEvent *event)
{
    if(event->mimeData()->hasUrls())
    {
        QList<QUrl> list = event->mimeData()->urls();
 
        for(int i = 0; i < list.count(); i++)
        {
            qDebug() << list[i].toLocalFile();
        }
    }
    else
    {
        event->ignore();
    }
}
 
Widget::~Widget()
{
}
```

[更加详细拖放简介](https://www.cnblogs.com/juzaizai/p/15303239.html)

# 数学问题

## 点乘与叉乘

点乘用于两个向量之间的**标量运算**，结果是一个数值。

![image-20241030114620850](image-20241030114620850.png)

叉乘是一个**向量运算**，结果是一个新向量，它与原来的两个向量都垂直。

![image-20241030114703040](image-20241030114703040.png)

# Linux

## 软硬链接

在Linux中，**硬链接**（Hard Link）是一种指向文件数据的链接方式，允许多个文件名指向相同的文件内容。这意味着通过硬链接创建的文件实际上是同一文件的多个路径引用。硬链接是**多个目录项中的「索引节点」指向一个文件**，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以**硬链接是不可用于跨文件系统的**。由于多个目录项都是指向一个 inode，那么**只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。**

### 特性

1. **共享相同的inode**：
   - 在硬链接和原文件之间，共享相同的inode（文件索引节点），即它们指向同一文件数据块。
   - 因此，通过硬链接创建的文件和原文件本质上是同一个文件。
2. **文件内容保持一致**：
   - 修改硬链接文件的内容，相应的原文件内容也会更新，反之亦然。
   - 但删除其中一个文件名，另一个仍然存在，文件数据不会被删除，除非所有硬链接都被删除。
3. **硬链接不适用于目录**：
   - 通常，硬链接只能用于文件，不能对目录使用（为避免文件系统循环引用的问题）。
4. **同一文件系统限制**：
   - 硬链接只能在同一个文件系统中创建，不能跨文件系统。

`ln`命令可以创建硬链接。

软链接相当于重新创建一个文件，这个文件有**独立的 inode**，但是这个**文件的内容是另外一个文件的路径**，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以**软链接是可以跨文件系统的**，甚至**目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。**



# 其他

\7. 单例： 1. 单例设计模式是一种创建型设计模式，保证一个类只有一个实例，并提供一个访问它的 全局访问点。 2. 如何设计单例模式： (1) 将构造函数、拷贝构造函数和析构函数的访问权限标记为protected或private； (2) 在类中定义一个公有的static函数，返回在类内部唯一构造的实例。 3. 懒汉模式和饿汉模式 (1) 懒汉模式：懒汉模式（Lazy Initialization）是一种设计模式，其核心思想是延 迟初始化，即对象在第一次使用时才进行创建，而不是在类加载时或程序启动时 立即创建。这种设计模式的优势在于，如果对象在实际使用中并未被引用，那么可 以节省系统资源，实现了延迟加载。 (2) 饿汉模式：饿汉模式（EagerInitialization）是单例模式的一种实现方式。其核 心特点是，在程序启动或类加载时就立即创建类的实例，因此也被称为“饱汉模 式”或“静态常量方式”。

MVC： 
1. MVC，全称Model-View-Controller，是一种软件设计模式，它将应用程序分成三个主要 组成部分：模型（Model）、视图（View）和控制器（Controller）。目的是将应用程序的业务逻辑、用户界面和用户输入分离开来，从而提高代码的可维护性和可重用性。 
2. 模型（Model）：
  - 是应用程序的核心，它代表应用程序的数据和业务逻辑。
  - 它通常包括数据访问对象、实体类和业务逻辑类等。 
  - 模型的主要职责是处理数据和提供业务逻辑，但它并不知道关于用户界面或控制器的任何信息。
3. 视图（View）： 
  - 视图是用户界面的呈现方式，它负责显示数据给用户。
  - 视图只显示数据，但不处理数据或业务逻辑。
  - 视图与模型和控制器是分离的，它不会对数据进行任何修改。 
4. 控制器（Controller）：
  - 控制器是应用程序的协调者，它负责处理用户输入并更新模型和视图。
  - 用户与视图进行交互（如点击按钮或输入数据）时，视图将用户的输入发送给控制器。
  - 控制器接收到用户的输入后，根据需要更新模型的状态或执行相应的操作。
  - 控制器还负责接收模型处理后的结果，并更新视图以显示更新后的数据给用户。 
5. MVC 模式的优点包括： 
  - 耦合性低：视图层和业务层分离，使得修改视图层代码而无需重新编译模型和控制器代码成为可能。同样，业务逻辑或流程的改变也只需修改模型层。 
  - 重用性高：多个视图可以共享同一个模型，使得不同的视图可以访问相同的服务端代码。 	(3) 部署快，生命周期成本低：MVC降低了开发和维护用户接口的技术难度，缩短了开发时间，并允许程序员专注于业务逻辑。 
  - 可维护性高：由于视图和业务逻辑分离，Web应用更易于维护和修改。 
6. MVC 模式也有一些缺点： 
  - 增加了系统结构和实现的复杂性：对于简单的界面，严格遵循MVC可能会导致结构复杂性和过多的更新操作，从而影响运行效率。 
  - 视图与控制器间的紧密连接：虽然视图和控制器是分离的，但它们之间的联系确实紧密，这妨碍了他们的独立重用。 
  - 数据连接： 视图对模型数据的低效率访问：在某些情况下，视图可能需要多次调用模型才能获取足够的显示数据，这可能导致性能问题。



# C语言/C++基础

## float比较

float 类型不能比较相等或不等，但可以比较>,<,>=,<=

本来应该相等的两个浮点数由于计算机内部表示的原因可能略有微小的误差，这时用==就会认为它们不等。应该使用两个浮点数之间的差异的绝对值小于某个可以接受的值来判断判断它们是否相等,

```c
if (fabs(price - p) < 0.000001)
//假设浮点变量的名字为x，应当将
if (x == 0.0) // 隐含错误的比较转化为
if ((x>=-EPSINON) && (x<=EPSINON))
//其中EPSINON 是允许的误差（即精度）。
```

不可将浮点变量用“==”或“！=”与任何数字比较。
千万要留意，无论是float 还是double 类型的变量，都有精度限制。所以一定要.
避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式。

## sizeof

```c++
char c=8;
int  i=32;
printf("%ld", sizeof(c));  // 结果:1, 因为char就是1字节
printf("%ld", sizeof(c+i));  // 结果:4, i是4字节, 运算时c值被隐式转换成int, 运算值是4字节
printf("%ld", sizeof(c=c+i));  // 结果:1, 等同于(c), 编译时, 因为=不被执行, 所以=的右边只是个屁 
```
```c++
// 小心, char和'a'在被=动作前, 是两个独立类型, 没关联
char c = 'a';  
printf("%ld", sizeof(c));      // 结果:1, char类型是1字节
printf("%ld", sizeof('a')；    // C结果:4，C++结果:1
                               // C99的标准，    'a'是整型字符常量，常量!常量!常量!被看成是int型， 所以占4字节。
                               // ISO C++的标准，'a'是字符字面量  ，被看成是char型，所以占1字节。
```
```c++
char *p;      //Linux中sizeof(p) = 4; 
char *p="hello"; //       sizeof(p) = 4; 求得是指针
char str[]="hello"; // sizeof(str) = 6 求得是数组，结尾'\0'
int b[5];   //sizeof(b) = 20
```

**当操作数是具体的字符串或者数值时，会根据具体的类型进行相应转化。**

参数数组例外：数组其实退化成了指针

```c++
void p(char str[100])
{
    cout<<sizeof(str)<<endl; //4 因为参数传过来都指针
}
```

结构体的时候需要记得内存对齐

## 常见STL之`upper_bound` `lower_bound`

### `lower_bound`

在已划分的范围 `[first, last)` 中查找第一个**不**先序于 value 的元素。便于理解就是一般比较带上等于。

函数原型：

```c++
template <class ForwardIterator, class T>
ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,  const T& val);

template <class ForwardIterator, class T, class Compare>
ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val, Compare comp);
```

所以，在已划分好的范围内（有序）中查找第一个不先序于`value`的元素即：

1. 通过`operator<`确定顺序

   返回 `[first, last)` 中首个使得 `bool(*iter < value)` 是 `false` 的迭代器 iter，或者在不存在这种 iter 的情况下返回 last。

   如果 `[first, last)` 的元素 elem 没有按表达式 bool(elem < value) 划分，那么行为未定义。

   等价于 std::lower_bound(first, last, value, std::less{})。

2. 通过`comp`划分即仿函数啊，函数对象、lambda等可调用的类型：

   返回 `[first, last)` 中首个使得 `bool(comp(*iter, value))` 是 false 的迭代器 iter，或者在不存在这种 iter 的情况下返回 last。

    如果 `[first, last)` 的元素 elem 没有按表达式 bool(comp(elem, value)) 划分，那么行为未定义。

3. 注意这里的比较 val值都是第二位，即容器内的元素为第一参数。**不先序于的意思就是判断为false，不小于即大于等于，从comp（*iter,val）为false**

示例：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main()
{
	vector<int> v = { 3,4,1,2,8 };
	// 先排序
	sort(v.begin(), v.end());  // 1 2 3 4 8
 
	// 定义两个迭代器变量
	vector<int>::iterator iter1;
	vector<int>::iterator iter2;
 
	// 在动态数组中寻找 >=3 出现的第一个数 并以迭代器的形式返回
	iter1 = lower_bound(v.begin(), v.end(), 3);  // -- 指向3
	// 在动态数组中寻找 >=7 出现的第一个数 并以迭代器的形式返回
	iter2 = lower_bound(v.begin(), v.end(), 7);  // -- 指向8
 
	cout << distance(v.begin(), iter1) << endl; //下标 2
	cout << distance(v.begin(), iter2) << endl; //下标 4 
	return 0;
}
```

有comp的示例，找到第一个小于20的元素（这里出现的20就是第三个参数val）

```c++
// 自定义函数  
// 目的是 找出 大于等于 val 的元素,注意lower_bound里找出的是comp（*iter，val）为false的第一个
bool cmp(const int& e, const int& val)
{
	return e >= val;
}
 
int main()
{
 
	// 有序数组---从大到小
	vector<int> v = { 30,28,26,25,21,20,19,16,1 };
 
	// lower_bound 的目的：找出第一个 false 自定义函数的值---即 第 1 个 < 20 的元素
	vector<int>::iterator it = lower_bound(v.begin(), v.end(), 20, cmp);
	if (it == v.end())
		cout << "未找到满足条件的元素" << endl;
	else
	{
		cout << *it << endl;     // 找到的元素为：19
		cout << it - v.begin() << endl;  // 下标为：6
	}
	   
	return 0;
}
```

找到第一个无法被5整除的元素

```c++
//val 5 ,comp(*iter,5) 为false是无法被5整除
bool cmp(const int& e,const int& val)
{
    return (e%val)==0; //true 代表能整除
}

int main()
{
    // 有序数组---从大到小
	vector<int> v = { 30,28,26,25,21,20,19,16,1 };
 
	// lower_bound 的目的：找出第一个 false 自定义函数的值---即 第 1 个 无法被 val整除 的元素
    vector<int>::iterator it=lower_bound(v.begin(),v.end(),5,cmp);
    if(it==v.end())cout<<"没找到\n";
    else
    {
        cout<<*it<<endl;
        cout<<"下标为: "<<it-v.begin()<<endl;
    }
    return 0;
}
```

> 注意，区间有序**关键在于和比较函数或方法密切相关**，默认是递增，相当于：lower_bound( begin , end , val , less<type>() ),这里升序，输出第一个不先序即（判断为false，就是第一个大于等与>=）。
>
> 而递减序列，在排序的时候可知sort(,,greater<type>()),那么：lower_bound( begin , end , val , greater<type>() )，输出第一个不先序（即>的判断为false时为<=）的数。
>
> ***尤其注意这里无论是默认或者仿函数或者各种比较函数，(*iter,val),注意容器里的数值的参数顺序***

### `upper_bound`

在已划分的范围 `[first, last)` 中查找第一个后序于 value 的元素。便于理解的话就是返回第一个大于的元素。

函数原型：

```c++
template< class ForwardIt, class T >
ForwardIt upper_bound( ForwardIt first, ForwardIt last,const T& value );

template< class ForwardIt, class T, class Compare >
ForwardIt upper_bound( ForwardIt first, ForwardIt last,const T& value, Compare comp );
```

所以，在已划分好的范围内（有序）中查找第一个后序于`value`的元素即：

1. 通过`operator<`确定顺序

   返回 `[first, last)` 中首个使得 `bool(value < *iter)` 是 `true` 的迭代器 iter，或者在不存在这种 iter 的情况下返回 last。

   如果 `[first, last)` 的元素 elem 没有按表达式 bool(value < elem) 划分，那么行为未定义。

   等价于 std::upper_bound(first, last, value, std::less{})。

2. 通过`comp`划分即仿函数啊，函数对象、lambda等可调用的类型：

   返回 `[first, last)` 中首个使得 `bool(comp(value, *iter))` 是 true 的迭代器 iter，或者在不存在这种 iter 的情况下返回 last。

    如果 `[first, last)` 的元素 elem 没有按表达式 bool(comp(value, elem)) 划分，那么行为未定义。

3. ***注意这里的比较 val值都是在第二位***，即容器内的元素为第二参数。**后序于的意思就是判断为true，大于是对的，从comp（value,*iter）为true**

示例：

```c++
int main()
{
	vector<int> v = { 3,4,1,2,8 };
	// 先排序
	sort(v.begin(), v.end());  // 1 2 3 4 8
 
	// 定义两个迭代器变量
	vector<int>::iterator iter1;
	vector<int>::iterator iter2;
 
	// 在动态数组中寻找 >3 出现的第一个数 并以迭代器的形式返回
	iter1 = upper_bound(v.begin(), v.end(), 3);  // -- 指向4
	// 在动态数组中寻找 >7 出现的第一个数 并以迭代器的形式返回
	iter2 = upper_bound(v.begin(), v.end(), 7);  // -- 指向8
 
	cout << distance(v.begin(), iter1) << endl; //下标 3
	cout << distance(v.begin(), iter2) << endl; //下标 4 
	return 0;
}
```

***\*找到第一个大于 5 的元素，返回其迭代器\****

```c++
bool cmp2(const int& val,const int& e) //后序即容器内值elem>value
{
    return val<e;
}

int main()
{
    vector<int> v={1,3,4,5,6,8,9};
    // upper_bound 的目的：找出第一个 true 自定义函数的值---即 第 1 个 大于 val 的元素
    
    vector<int>::iterator it=upper_bound(v.begin(),v.end(),5,cmp);
    if (it == v.end())
		cout << "未找到满足条件的元素" << endl;
	else
	{
		cout << *it << endl;     // 找到的元素为：6
		cout << it - v.begin() << endl;  // 下标为：4
	}
	   
	return 0;
}
```

 ***\*找到第一个能被 5 整除 的元素\****

```c++
bool cmp2(const int& value,const int& elem)
{
    return (elem%value)==0;
}

int main()
{
 
	vector<int> v = { 1,3,4,5,6,8,9 };
 
	// upper_bound 的目的：找出第一个 true 自定义函数的值---即 第 1 个 能够被val整除 的元素
	vector<int>::iterator it = upper_bound(v.begin(), v.end(), 5, cmp2);
	if (it == v.end())
		cout << "未找到满足条件的元素" << endl;
	else
	{
		cout << *it << endl;     // 找到的元素为：5
		cout << it - v.begin() << endl;  // 下标为：3
	}
	   
	return 0;
}
```

> 注意，区间有序**关键在于和比较函数或方法密切相关**，默认如果是递增，相当于：lower_bound( begin , end , val , less<type>() ),这里升序，输出第一个后序即（判断为true，就是第一个 value<elem 的elem）。
>
> 而递减序列，在排序的时候可知sort(,,greater<type>()),那么：lower_bound( begin , end , val , greater<type>() )，输出第一个后序（即>的判断为true时为 value>elem 的elem）的数。

***尤其注意这里无论是默认或者仿函数或者各种比较函数，(value,*iter),注意容器里的数值的参数顺序***

### 对比

对于 `[first, last)` 中的任意迭代器 iter，`std::upper_bound` (后序)要求 value < *iter 和 comp(value, *iter) 良构，而 std::lower_bound 要求 `*iter` < value 和 comp( *iter, value) 良构。

|                    | lower_bound              | upper_bound              |
| ------------------ | ------------------------ | ------------------------ |
| 无自定义比较函数   | 返回首个不先序           | 返回首个后序的           |
| 使用自定义比较函数 | comp(*iter,value)为false | comp(value，*iter)为true |

> 特别注意，序列有序的时候的排序准则要和lower_bound或upper_bound的comp一致，否则可能有未定义行为。
> *说明*：***假如序列排序规则，a<b ,或者 comp(a,b)==true,那么lower_bound对应：( * iter) <value（第三个参数）;而comp( * iter,value );不先序就是无论何种规则，容器内的元素在前 要 false ***。
>
> 假如序列排序规则，a<b ,或者 comp(a,b)==true,那么upper_bound对应：value< * iter; comp(value, * iter) 为true，无论何种规则，容器内元素后序得为true。
>
> 假如序列排序规则，a>b ,或者 comp(b,a)==true,
> lower_bound 对应 * iter > value 或 comp（* iter ，value ）得为false
>
> upper_bound 对应 value> * iter 或 comp( value, * iter )得为true



总之一句话，不先序或者后序这里的先后 都是只比较的元素和判断的标准的相对位置。
